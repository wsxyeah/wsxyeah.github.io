<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王少星的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wsxyeah.github.io/"/>
  <updated>2019-08-18T00:48:49.945Z</updated>
  <id>https://wsxyeah.github.io/</id>
  
  <author>
    <name>王少星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koltin 中 Lambda 变量捕获</title>
    <link href="https://wsxyeah.github.io/2019/08/18/lambda-captures-in-kotlin/"/>
    <id>https://wsxyeah.github.io/2019/08/18/lambda-captures-in-kotlin/</id>
    <published>2019-08-18T00:43:24.000Z</published>
    <updated>2019-08-18T00:48:49.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-中-Lambda-变量捕获"><a href="#Java-中-Lambda-变量捕获" class="headerlink" title="Java 中 Lambda 变量捕获"></a>Java 中 Lambda 变量捕获</h2><p>Java 中 lambda 的变量捕获是值的捕获，也就是直接把捕获的变量拷贝一份，这意味着对于栈上的变量，你如果在 lambda 中想对其赋值，对原始变量是不会生效的，所以 Java 干脆禁止这样做，强制你将其声明为 final。<br>当然如果真的需要改变原始的值的话，IDE 会提示你可以用 Atomic 类或者一个单元素的数组包装一下，这样捕获时是将 Atomic 对象或者数组变量拷贝一份，而他们指向的数据都是堆上的同一份数据。</p><h2 id="Koltin-中-Lambda-变量捕获"><a href="#Koltin-中-Lambda-变量捕获" class="headerlink" title="Koltin 中 Lambda 变量捕获"></a>Koltin 中 Lambda 变量捕获</h2><p>随便写个 demo 反编译下可以发现如果你在 lambda 中对捕获的变量有赋值操作，在 JVM 平台上编译器就会自动帮你把变量包装成一个 Ref 对象，原理跟上面提到的 Java 中的解决方式本质上是一样的。参考 <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Ref.java" target="_blank" rel="noopener">Ref.java</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-中-Lambda-变量捕获&quot;&gt;&lt;a href=&quot;#Java-中-Lambda-变量捕获&quot; class=&quot;headerlink&quot; title=&quot;Java 中 Lambda 变量捕获&quot;&gt;&lt;/a&gt;Java 中 Lambda 变量捕获&lt;/h2&gt;&lt;p&gt;Java 中
      
    
    </summary>
    
    
      <category term="kotlin" scheme="https://wsxyeah.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio Apply Changes</title>
    <link href="https://wsxyeah.github.io/2019/08/06/android-studio-apply-changes/"/>
    <id>https://wsxyeah.github.io/2019/08/06/android-studio-apply-changes/</id>
    <published>2019-08-05T23:25:59.000Z</published>
    <updated>2019-08-05T23:51:11.310Z</updated>
    
    <content type="html"><![CDATA[<p>探究 Android Studio 3.5 新增的 <code>Apply Changes</code> 功能。</p><ul><li><a href="https://medium.com/androiddevelopers/android-studio-project-marble-apply-changes-e3048662e8cd" target="_blank" rel="noopener">Android Studio Project Marble: Apply Changes</a></li><li><a href="https://www.zhihu.com/question/309772986" target="_blank" rel="noopener">Android Studio 3.5提供的”Apply Changes“是什么原理？</a></li><li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/deploy/" target="_blank" rel="noopener">Source Code</a></li><li><a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html" target="_blank" rel="noopener">JVM(TM) Tool Interface</a></li><li><a href="http://jm.taobao.org/2011/03/15/756/" target="_blank" rel="noopener">JVMTI开发教程之一个简单的Agent</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html" target="_blank" rel="noopener">JVMTI 和 Agent 实现</a></li></ul><a id="more"></a><h2 id="Instant-Run"><a href="#Instant-Run" class="headerlink" title="Instant Run"></a><a href="https://medium.com/google-developers/instant-run-how-does-it-work-294a1633367f" target="_blank" rel="noopener">Instant Run</a></h2><ul><li>构建过程动手脚</li><li>Apk 里藏私货</li><li>自定义 ClassLoader 热部署</li><li>兼容性一般</li></ul><p><img src="https://miro.medium.com/max/1400/1*U2tXGUWaeDU7L3u9Z_U0fw.png" alt="Instant Run"></p><h2 id="Apply-Changes"><a href="#Apply-Changes" class="headerlink" title="Apply Changes"></a>Apply Changes</h2><ul><li>不关心构建过程，只对 apk 做 diff</li><li>基于 JVMTI，需要 Android O+</li></ul><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>对设备上安装的 apk 与新 apk 做 diff</li><li>将 diff 推到设备上并应用改动</li></ol><h3 id="改动类型支持"><a href="#改动类型支持" class="headerlink" title="改动类型支持"></a>改动类型支持</h3><ol><li>仅 res/assets 改动：应用改动的资源，重启 Activity</li><li>仅 dex 改动：改动不能影响对象的内存布局，基于 JVMTI 进行类级别的 hot swap</li><li>资源改动 + dex 改动</li><li>其他改动：不支持</li></ol><h3 id="增量更新流程"><a href="#增量更新流程" class="headerlink" title="增量更新流程"></a>增量更新流程</h3><ol><li>解析新 apk 的 zip entries</li><li>拉取已安装的 apk 的 zip entries</li><li>对以上两个列表做 diff，得出变更文件的列表</li><li>根据文件列表 diff 验证是否支持 apply changes（是否改动 dex，资源之外的内容）</li><li>根据 diff 计算（粒度为 zip entry 级别）dirty map，生成 instructions &amp; patch。<strong>注意这里不需要全量拉取已安装的 apk</strong>。</li></ol><svg width="373" height="154" viewbox="0 0 373 154" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="52" y="1" width="55" height="64" fill="#C4C4C4"/><rect x="107" y="1" width="76" height="64" fill="#7A7A7A"/><rect x="183" y="1" width="76" height="64" fill="#C4C4C4"/><rect x="259" y="1" width="37" height="64" fill="#7A7A7A"/><rect x="296" y="1" width="76" height="64" fill="#C4C4C4"/><rect x="51.5" y="0.5" width="321" height="65" stroke="#B4B4B4"/><rect x="259" y="90" width="54" height="64" fill="#93C595"/><rect x="107" y="90" width="103" height="64" fill="#93C595"/><text fill="black" xml:space="preserve" style="white-space: pre" font-family="Roboto" font-size="12" letter-spacing="0em"><tspan x="143" y="126.102">patch</tspan></text><text fill="black" xml:space="preserve" style="white-space: pre" font-family="Roboto" font-size="12" letter-spacing="0em"><tspan x="0" y="62.1016">old apk</tspan></text><text fill="white" xml:space="preserve" style="white-space: pre" font-family="Roboto" font-size="12" letter-spacing="0em"><tspan x="133" y="37.1016">dirty</tspan></text><text fill="white" xml:space="preserve" style="white-space: pre" font-family="Roboto" font-size="12" letter-spacing="0em"><tspan x="266" y="37.1016">dirty</tspan></text><text fill="black" xml:space="preserve" style="white-space: pre" font-family="Roboto" font-size="12" letter-spacing="0em"><tspan x="271" y="126.102">patch</tspan></text><path d="M277.646 90.3536C277.842 90.5488 278.158 90.5488 278.354 90.3536L281.536 87.1716C281.731 86.9763 281.731 86.6597 281.536 86.4645C281.34 86.2692 281.024 86.2692 280.828 86.4645L278 89.2929L275.172 86.4645C274.976 86.2692 274.66 86.2692 274.464 86.4645C274.269 86.6597 274.269 86.9763 274.464 87.1716L277.646 90.3536ZM277.5 65L277.5 90L278.5 90L278.5 65L277.5 65Z" fill="black"/><path d="M144.646 90.3536C144.842 90.5488 145.158 90.5488 145.354 90.3536L148.536 87.1716C148.731 86.9763 148.731 86.6597 148.536 86.4645C148.34 86.2692 148.024 86.2692 147.828 86.4645L145 89.2929L142.172 86.4645C141.976 86.2692 141.66 86.2692 141.464 86.4645C141.269 86.6597 141.269 86.9763 141.464 87.1716L144.646 90.3536ZM144.5 65L144.5 90L145.5 90L145.5 65L144.5 65Z" fill="black"/></svg><ol start="6"><li>deltaPreInstall：adb 调用 <code>cmd package install-create</code> 创建 session，<code>install-write</code> 写入 instructions &amp; patch 数据。</li><li>对 dex （里的类）进行 diff，得到需要 swap 的类列表。这里注意两点：<br> （1）类的 diff 只用比较 checksum<br> （2）dex 里类的信息其实是从数据库取的（预先写进去的）而非拉取设备上的 dex， ( &gt;﹏&lt;。)～ 这个问题卡了我好久，其实流程图上有写。</li><li>Swap！adb 调用 <code>installer</code> 执行 swap</li><li>Commit install</li></ol><p><img src="https://miro.medium.com/max/2000/1*aD1y7EprEnSzM-3FwbUsRQ.png" alt="flow"></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/ZIP-64_Internal_Layout.svg/2560px-ZIP-64_Internal_Layout.svg.png" alt="zip"></p><h3 id="Swap-amp-JVMTI-Agent"><a href="#Swap-amp-JVMTI-Agent" class="headerlink" title="Swap &amp; JVMTI Agent"></a>Swap &amp; JVMTI Agent</h3><ol><li><code>installer</code> 进程开启一个 socket server</li><li>通过 <code>cmd activity attach-agent &lt;PROCESS&gt; &lt;FILE&gt;</code> attach agent 到指定进程</li><li>Attach 成功后，agent 通过 socket 从 <code>installer</code> 读取数据</li><li>InstrumentApplication：<ol><li><a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#SetEventCallbacks" target="_blank" rel="noopener">SetEventCallbacks</a>：<code>callbacks.ClassFileLoadHook = Agent_ClassFileLoadHook</code></li><li>加载 instrumentation jar 包</li><li><code>RetransformClasses</code>，触发前面设置的 <a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#ClassFileLoadHook" target="_blank" rel="noopener"><code>ClassFileLoadHook</code></a>：Hook <code>ActivityThread.handleDispatchPackageBroadcast()</code>，更新资源。</li></ol></li><li>HotSwap：<a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#RedefineClasses" target="_blank" rel="noopener">RedefineClasses</a></li></ol><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">agent/      JVMTI agent 实现，编译成 so 文件，拷贝到 app 的 data 目录下，通过 JVMTI attach 到对应的进程上。</span><br><span class="line">bench.sh</span><br><span class="line">common/</span><br><span class="line">deployer/   Android Studio 端操作流程逻辑</span><br><span class="line">installer/  编译成二进制可执行文件，安装 apk 时会被 push 到 /data/local/tmp/.studio/bin/installer，跑在设备端，由 Android Studio 通过 adb 调用。目前支持三个操作：`dump`，`swap`，`deltapreinstall`。</span><br><span class="line">proto/      PB 定义</span><br><span class="line">summary.py</span><br><span class="line">test/</span><br></pre></td></tr></table></figure><p>核心逻辑可以参考 <a href="deployer/src/main/java/com/android/tools/deployer/Deployer.java">deployer/src/main/java/com/android/tools/deployer/Deployer.java</a> 的 <code>swap</code> 方法，十分清晰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Get the list of files from the local apks</span><br><span class="line">// Get the list of files from the installed app</span><br><span class="line">// Calculate the difference between them</span><br><span class="line">// Push the apks to device and get the remote paths</span><br><span class="line">// Verify the changes are swappable and get only the dexes that we can change</span><br><span class="line">// Compare the local vs remote dex files.</span><br><span class="line">// Do the swap</span><br><span class="line">// Update the database with the entire new apk.</span><br><span class="line">// Wait only for swap to finish</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探究 Android Studio 3.5 新增的 &lt;code&gt;Apply Changes&lt;/code&gt; 功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/androiddevelopers/android-studio-project-marble-apply-changes-e3048662e8cd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio Project Marble: Apply Changes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/309772986&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio 3.5提供的”Apply Changes“是什么原理？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://android.googlesource.com/platform/tools/base/+/studio-master-dev/deploy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVM(TM) Tool Interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jm.taobao.org/2011/03/15/756/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVMTI开发教程之一个简单的Agent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVMTI 和 Agent 实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 里 switch 语句对 String 的支持</title>
    <link href="https://wsxyeah.github.io/2018/09/14/java-strings-in-switch-statements/"/>
    <id>https://wsxyeah.github.io/2018/09/14/java-strings-in-switch-statements/</id>
    <published>2018-09-14T13:02:57.000Z</published>
    <updated>2018-09-14T13:32:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 里 switch 语句是在 JDK 7 开始支持的，现在可以支持 <code>char, byte, short, int, Character, Byte, Short, Integer, String</code> 类型。</p><a id="more"></a><p>今天读 flutter 代码的时候无意间发现 switch 语句对 String 的支持是通过 <code>hashCode</code> 配合 <code>equals</code> 实现的 😂。</p><p><del>鉴于 Blog 好久没更新了，特地来水一篇。</del>不多说了，看下代码。</p><p>这是源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (method.getName()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"addView"</span>:</span><br><span class="line">            addView(args);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"removeView"</span>:</span><br><span class="line">            removeView(args);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"updateViewLayout"</span>:</span><br><span class="line">            updateViewLayout(args);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mDelegate, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是反编译过的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String var4 = method.getName();</span><br><span class="line">    <span class="keyword">byte</span> var5 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(var4.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1148522778</span>:</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">"addView"</span>)) &#123;</span><br><span class="line">            var5 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">931413976</span>:</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">"updateViewLayout"</span>)) &#123;</span><br><span class="line">            var5 = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1098630473</span>:</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">"removeView"</span>)) &#123;</span><br><span class="line">            var5 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(var5) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">this</span>.addView(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">this</span>.removeView(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">this</span>.updateViewLayout(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.mDelegate, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var6.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 里 switch 语句是在 JDK 7 开始支持的，现在可以支持 &lt;code&gt;char, byte, short, int, Character, Byte, Short, Integer, String&lt;/code&gt; 类型。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈 View 的构造方法们</title>
    <link href="https://wsxyeah.github.io/2018/01/03/view-constructors/"/>
    <id>https://wsxyeah.github.io/2018/01/03/view-constructors/</id>
    <published>2018-01-03T14:54:32.000Z</published>
    <updated>2018-05-13T04:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 中，要实现自定义 View，可以通过继承已有的 View 来实现，并且要写对应的构造方法。</p><p>View 有四个主要的构造方法，第四个需要在 API 21 以上，一般而言我们都会实现前三个。</p><ul><li><code>public View(Context context)</code></li><li><code>public View(Context context, @Nullable AttributeSet attrs)</code></li><li><code>public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr)</code></li><li><code>public View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)</code></li></ul><a id="more"></a><p>下面来看一种常见的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面几个构造方法中调用 this， 再在后面的构造方法中统一调用 super。这种写法的确很常见，在各种开源库甚至 Android 自己的一些 View 都采用了这种写法。然而如果你对此不假思索地照抄下来，还是可能会遇到坑的。</p><p>先来看下这些构造方法的用途。</p><ul><li>只有一个 Context 参数的构造方法其实主要是给我们手动创建 View（<code>new View(context)</code>）用的。</li><li>第二个构造方法用于从布局文件中创建（inflate） View，会在 inflate 过程中通过反射被调用到。</li><li>后面两个构造方法并不会由系统去调用，主要是给子类 View 调用父类构造方法初始化用的。</li></ul><p>View 的构造方法是用来初始化 View 属性（比如背景，边距，id，文字大小，文字颜色等等）的，那么这些初始值从哪里来以及如何获取就是我们首先要关心的。根据我们的经验，这些值通常是在布局文件，或者 Style 中指定。通过查看 View 的源码我们可以发现这些值的查找是通过 Context 的 <code>public final TypedArray obtainStyledAttributes(AttributeSet set, @StyleableRes int[] attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes)</code> 方法完成的，这个方法中的参数对应于与 View 构造方法中的参数。</p><p>让我们来看一下这几个参数。</p><ul><li><p><code>AttributeSet attrs</code> 是我们在布局文件里面为该 View 定义的属性集，比如为一个 TextView 指定 <code>android:textSize=&quot;16sp&quot; android:textColor: &quot;#666&quot;</code>。值得注意的是我们可以在布局文件中为 View 指定 <code>style</code> 属性，引用一个 Style 资源，这样如果相关属性没有在布局文件中没有直接指定的话，就会去 Style 中查找。</p></li><li><p>以 def 命名的参数是指 default。<code>int defStyleAttr</code> 其实是一个 attr 资源，它对应于当前 Theme 中的一项属性，其值是对一个 Style 的引用。那么有了这个参数，如果要查找的属性通过 <code>AttributeSet attrs</code> 找不到，我们就可以去当前 Theme 中由 defStyleAttr 引用的 Style 中查找。</p><p>  举个例子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"@style/Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"buttonStyle"</span>&gt;</span>@style/MyButtonStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"MyButtonStyle"</span> <span class="attr">parent</span>=<span class="string">"Base.TextAppearance.AppCompat.Widget.Button"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>@android:color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textSize"</span>&gt;</span>24dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  我们可以通过在 Theme 中定义 <code>buttonStyle</code> 属性来更改 Button 的默认样式。这里的 <code>buttonStyle</code> 就是一个 attr 资源 <code>&lt;attr name=&quot;buttonStyle&quot; format=&quot;reference&quot; /&gt;</code>，它的值就是对我们自己定义的 Style <code>MyButtonStyle</code> 的引用。这样，如果我们没有在布局文件里给 Button 定义 <code>android:textSize</code> 的话，它就会去 MyButtonStyle 中查找。</p><p>  那么如果我们没有指定 defStyleAttr 参数（传 0 进去），或者我们的 Theme 并没有定义 defStyleAttr 呢？ 那就要看最后一个参数了。</p></li><li><p>最后一个参数 <code>int defStyleRes</code> 显然是一个 Style 资源了，在前面的地方都相关属性都找不到的情况下，就可以从这个指定的 Style 中去查找相关属性。</p></li><li><p>当然，还有最后一个查找位置就是我们直接在 Theme 中定义的属性了。</p></li></ul><p>那么了解了这些基础之后，让我们再来回顾下上文提到的写法。</p><p>考虑这样一种情况，我们要继承的父类 View 同样实现了以上几个构造方法，而且用到了 <code>defStyleAttr</code> 和 <code>defStyleRes</code> 属性。</p><p>比如 Button 的构造方法是这样写的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, attrs, com.android.internal.R.attr.buttonStyle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Button</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它指定了会从当前 Theme 中的 <code>buttonStyle</code> 中去查找默认样式，而如果按照上文中的写法，我们继承了 Button 类又刚好在构造方法中去调用 this(…) 构造方法，最后才调用一下 super，那么 Button 的构造方法接收到的 <code>defStyleAttr</code> 也就不是 <code>com.android.internal.R.attr.buttonStyle</code>，而是 0，这样就导致了我们的 Button 无法从 Theme 中获取默认样式。这种情况显然不是我们所期望的。</p><p>其实后面两个构造方法要传 <code>int defStyleAttr</code> 与 <code>int defStyleRes</code> 进去，也就意味着会改变默认属性的查找位置，所以只有我们需要覆盖父类的默认样式时才应该去调用这两个构造方法，否则我们最好调用第二个构造方法 <code>super(context, attrs)</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Android 中，要实现自定义 View，可以通过继承已有的 View 来实现，并且要写对应的构造方法。&lt;/p&gt;
&lt;p&gt;View 有四个主要的构造方法，第四个需要在 API 21 以上，一般而言我们都会实现前三个。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public View(Context context)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public View(Context context, @Nullable AttributeSet attrs)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>No more magic - React Redux</title>
    <link href="https://wsxyeah.github.io/2017/07/15/no-more-magic-react-redux/"/>
    <id>https://wsxyeah.github.io/2017/07/15/no-more-magic-react-redux/</id>
    <published>2017-07-15T14:26:57.000Z</published>
    <updated>2017-08-13T02:26:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redux 作为一个状态管理工具，Redux 库本身仅负责状态管理，职责就很纯粹，而与 View 层粘合的部分（比如本文要讲的 React Redux）则单独拆出来。这使做它可以灵活地与多种 View 层实现组合使用，这一点很值得学习。</p><p>本文将解析胶水 React Redux 背后的 magic。</p><a id="more"></a><h2 id="使用-React-Redux-的一般姿势"><a href="#使用-React-Redux-的一般姿势" class="headerlink" title="使用 React Redux 的一般姿势"></a>使用 React Redux 的一般姿势</h2><p>Redux 官方文档给出了使用 React Redux 来给 React 集成 Redux 的用法。</p><p>根据文档，整体思想是由一个顶级的容器组件来持有和管理 state，子组件作为展示型组件，接受父组件传递的 props 并 render 出来。当然，这些 props 最终来源于容器组件所持有的的全局 state。</p><p>首先看官方的示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>Provider 的角色就是上文中的容器组件。这里将 Provider 作为顶级组件，并将 store 作为 props 传递给它。</p><p>再来看对子组件的包装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList</span><br></pre></td></tr></table></figure><p>对子组件的包装通过 <code>connect</code> 函数来实现，先传递 <code>mapStateToProps</code>，<code>mapDispatchToProps</code> 给 <code>connect</code> 得到一个新的函数，再把子组件传进去得到包装后的组件。这个包装出来的组件就会在合适的时机通过某种魔法调用 <code>mapStateToProps</code>，<code>mapDispatchToProps</code> 并将结果作为 props 传递给子组件，这样子组件就可以访问全局 state，或者 dispatch action 了。</p><p>其实这里 <code>connect</code> 相关的部分就是高阶组件（Higher Order Component）的角色，它是一个函数，接受组件作为参数，并返回包装后的组件。我们通过 ReactDevTools 可以探查到生成的组件是直接包在我们原来的组件外面的，比如我们有一个叫 Home 的组件，返回的组件树如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connect(Home)&gt;</span><br><span class="line">  &lt;Home/&gt;</span><br><span class="line">&lt;/Connect&gt;</span><br></pre></td></tr></table></figure><p>那么根据 React Redux 的用法，我们主要的关注点就是两个：<code>Provider</code> 组件与 <code>connect</code> 函数。</p><h2 id="Provider-组件"><a href="#Provider-组件" class="headerlink" title="Provider 组件"></a>Provider 组件</h2><p><code>Provider</code> 组件由 <code>createProvider</code> 函数创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provider.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createProvider</span>(<span class="params">storeKey = <span class="string">'store'</span>, subKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> subscriptionKey = subKey || <span class="string">`<span class="subst">$&#123;storeKey&#125;</span>Subscription`</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        getChildContext() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; [storeKey]: <span class="keyword">this</span>[storeKey], [subscriptionKey]: <span class="literal">null</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">          <span class="keyword">super</span>(props, context)</span><br><span class="line">          <span class="keyword">this</span>[storeKey] = props.store;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">          <span class="keyword">return</span> Children.only(<span class="keyword">this</span>.props.children)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Provider.propTypes = &#123;</span><br><span class="line">        store: storeShape.isRequired,</span><br><span class="line">        children: PropTypes.element.isRequired,</span><br><span class="line">    &#125;</span><br><span class="line">    Provider.childContextTypes = &#123;</span><br><span class="line">        [storeKey]: storeShape.isRequired,</span><br><span class="line">        [subscriptionKey]: subscriptionShape,</span><br><span class="line">    &#125;</span><br><span class="line">    Provider.displayName = <span class="string">'Provider'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Provider</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createProvider()</span><br></pre></td></tr></table></figure><p>那么这里的重点就是 <code>getChildContext</code> 方法，它的返回值包含了对 store 的引用。<code>Provider</code> 就是通过 <code>getChildContext</code> 来向组件树提供 context（store）的。</p><p>关于 context，它的作用是向下传递数据，与 props 相比，context 不需要一级一级地手动传下去，而下面的<strong>任何组件</strong>都能够通过 <code>this.context</code> 直接访问 context。</p><p>官方文档对 context 有更加详细的解释（<a href="https://facebook.github.io/react/docs/context.html" target="_blank">Context</a>）。</p><h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createConnect with default args builds the 'official' connect behavior. Calling it with</span></span><br><span class="line"><span class="comment">// different options opens up some testing and extensibility scenarios</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createConnect</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  connectHOC = connectAdvanced,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapStateToPropsFactories = defaultMapStateToPropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  mergePropsFactories = defaultMergePropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  selectorFactory = defaultSelectorFactory</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里就是 connect 函数了</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    mapStateToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mapDispatchToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mergeProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      pure = true,</span></span></span><br><span class="line"><span class="function"><span class="params">      areStatesEqual = strictEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areOwnPropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areStatePropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areMergedPropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      ...extraOptions</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125; = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, <span class="string">'mapStateToProps'</span>)</span><br><span class="line">    <span class="keyword">const</span> initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, <span class="string">'mapDispatchToProps'</span>)</span><br><span class="line">    <span class="keyword">const</span> initMergeProps = match(mergeProps, mergePropsFactories, <span class="string">'mergeProps'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 connectHOC 调用的结果</span></span><br><span class="line">    <span class="keyword">return</span> connectHOC(selectorFactory, &#123;</span><br><span class="line">      <span class="comment">// used in error messages</span></span><br><span class="line">      methodName: <span class="string">'connect'</span>,</span><br><span class="line"></span><br><span class="line">       <span class="comment">// used to compute Connect's displayName from the wrapped component's displayName.</span></span><br><span class="line">      getDisplayName: <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`Connect(<span class="subst">$&#123;name&#125;</span>)`</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes</span></span><br><span class="line">      shouldHandleStateChanges: <span class="built_in">Boolean</span>(mapStateToProps),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// passed through to selectorFactory</span></span><br><span class="line">      initMapStateToProps,</span><br><span class="line">      initMapDispatchToProps,</span><br><span class="line">      initMergeProps,</span><br><span class="line">      pure,</span><br><span class="line">      areStatesEqual,</span><br><span class="line">      areOwnPropsEqual,</span><br><span class="line">      areStatePropsEqual,</span><br><span class="line">      areMergedPropsEqual,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// any extra options args can override defaults of connect or connectAdvanced</span></span><br><span class="line">      ...extraOptions</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createConnect()</span><br></pre></td></tr></table></figure><p><code>connect</code> 通过 <code>createConnect()</code> 创建出来，<code>connect</code> 的核心实现在 <code>connectHOC</code>（即<code>connectAdvanced</code>）里。</p><p><code>connectAdvanced</code> 返回了函数 <code>function wrapWithConnect(WrappedComponent)</code>，也就是说这个 <code>WrappedComponent</code>就是我们自己的组件，而 <code>wrapWithConnect</code> 返回了一个 <code>Connect</code> 组件，它就是最终包装得到的组件。</p><p>在 Redux 中，我们要拿到 store 的 state，就应该先去 subscribe 这个 store，然后在 state 更新之后得到通知。我们的组件要想在 state 更新时得到通知，就得靠 <code>Connect</code> 先订阅 store，然后传 props 过来。所以这个 <code>Connect</code> 的实现也是八九不离十了，它应该是先订阅了 store，在 state 更新后再调用 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code>，组合之后作为 props 传给子组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">addExtraProps(props) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!withRef &amp;&amp; !renderCountProp &amp;&amp; !(<span class="keyword">this</span>.propsMode &amp;&amp; <span class="keyword">this</span>.subscription)) <span class="keyword">return</span> props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> withExtras = &#123; ...props &#125;</span><br><span class="line">  <span class="keyword">if</span> (withRef) withExtras.ref = <span class="keyword">this</span>.setWrappedInstance</span><br><span class="line">  <span class="keyword">if</span> (renderCountProp) withExtras[renderCountProp] = <span class="keyword">this</span>.renderCount++</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.propsMode &amp;&amp; <span class="keyword">this</span>.subscription) withExtras[subscriptionKey] = <span class="keyword">this</span>.subscription</span><br><span class="line">  <span class="keyword">return</span> withExtras</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> selector = <span class="keyword">this</span>.selector</span><br><span class="line">  selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (selector.error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> selector.error</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 给子组件加了 selector.props 属性，</span></span><br><span class="line">    <span class="comment">// 也就是 mapStateToProps, mapDispatchToProps 返回的东西</span></span><br><span class="line">    <span class="keyword">return</span> createElement(WrappedComponent, <span class="keyword">this</span>.addExtraProps(selector.props))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSelectorStateful</span>(<span class="params">sourceSelector, store</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// wrap the selector in an object that tracks its results between runs.</span></span><br><span class="line">  <span class="keyword">const</span> selector = &#123;</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> <span class="title">runComponentSelector</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> nextProps = sourceSelector(store.getState(), props)</span><br><span class="line">        <span class="keyword">if</span> (nextProps !== selector.props || selector.error) &#123;</span><br><span class="line">          selector.shouldComponentUpdate = <span class="literal">true</span></span><br><span class="line">          selector.props = nextProps</span><br><span class="line">          selector.error = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        selector.shouldComponentUpdate = <span class="literal">true</span></span><br><span class="line">        selector.error = error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> selector</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props, context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.renderCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 从 props 或 context 里取出 store</span></span><br><span class="line">    <span class="keyword">this</span>.store = props[storeKey] || context[storeKey]</span><br><span class="line">    <span class="keyword">this</span>.propsMode = <span class="built_in">Boolean</span>(props[storeKey])</span><br><span class="line">    <span class="keyword">this</span>.setWrappedInstance = <span class="keyword">this</span>.setWrappedInstance.bind(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 this.selector</span></span><br><span class="line">    <span class="keyword">this</span>.initSelector()</span><br><span class="line">    <span class="comment">// 订阅 store</span></span><br><span class="line">    <span class="keyword">this</span>.initSubscription()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initSelector() &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceSelector = selectorFactory(<span class="keyword">this</span>.store.dispatch, selectorFactoryOptions)</span><br><span class="line">    <span class="comment">// 方法定义见上面</span></span><br><span class="line">    <span class="comment">// 返回的对象 selector 对象包含一个 run 方法，</span></span><br><span class="line">    <span class="comment">// run 方法会调用 selector 函数计算出新的 props，并把 props 作为属性暴露出来，</span></span><br><span class="line">    <span class="comment">// 也就是 render 方法中所读取的 selector.props</span></span><br><span class="line">    <span class="keyword">this</span>.selector = makeSelectorStateful(sourceSelector, <span class="keyword">this</span>.store)</span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initSubscription() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!shouldHandleStateChanges) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parentSub = (<span class="keyword">this</span>.propsMode ? <span class="keyword">this</span>.props : <span class="keyword">this</span>.context)[subscriptionKey]</span><br><span class="line">    <span class="comment">// Subscription 是用来管理订阅的一个工具类，这里的 onStateChange 函数会接收 state 更新</span></span><br><span class="line">    <span class="keyword">this</span>.subscription = <span class="keyword">new</span> Subscription(<span class="keyword">this</span>.store, parentSub, <span class="keyword">this</span>.onStateChange.bind(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.notifyNestedSubs = <span class="keyword">this</span>.subscription.notifyNestedSubs.bind(<span class="keyword">this</span>.subscription)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!shouldHandleStateChanges) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.subscription.trySubscribe()</span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.selector.shouldComponentUpdate) <span class="keyword">this</span>.forceUpdate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector.run(nextProps)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selector.shouldComponentUpdate</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.subscription) <span class="keyword">this</span>.subscription.tryUnsubscribe()</span><br><span class="line">    <span class="keyword">this</span>.subscription = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.notifyNestedSubs = noop</span><br><span class="line">    <span class="keyword">this</span>.store = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.selector.run = noop</span><br><span class="line">    <span class="keyword">this</span>.selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state 有更新</span></span><br><span class="line">  onStateChange() &#123;</span><br><span class="line">    <span class="comment">// 计算 selector.props</span></span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.selector.shouldComponentUpdate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.notifyNestedSubs()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.componentDidUpdate = <span class="keyword">this</span>.notifyNestedSubsOnComponentDidUpdate</span><br><span class="line">      <span class="comment">// 调用 setState 触发 render</span></span><br><span class="line">      <span class="keyword">this</span>.setState(dummyState)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notifyNestedSubsOnComponentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">this</span>.componentDidUpdate = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.notifyNestedSubs()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Connect</code> 订阅了 store，并在 <code>onStateChange</code> 中令 selector 重新计算 props，之后 setState 触发组件的 render，使子组件的 props 得到更新。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://redux.js.org/docs/basics/UsageWithReact.html" target="_blank">Redux Usage with React</a></li><li></li><li><a href="https://facebook.github.io/react/docs/context.html" target="_blank">React Context</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redux 作为一个状态管理工具，Redux 库本身仅负责状态管理，职责就很纯粹，而与 View 层粘合的部分（比如本文要讲的 React Redux）则单独拆出来。这使做它可以灵活地与多种 View 层实现组合使用，这一点很值得学习。&lt;/p&gt;
&lt;p&gt;本文将解析胶水 React Redux 背后的 magic。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用 Word 写论文的一点儿经验</title>
    <link href="https://wsxyeah.github.io/2017/05/20/Microsoft-Word-Skills/"/>
    <id>https://wsxyeah.github.io/2017/05/20/Microsoft-Word-Skills/</id>
    <published>2017-05-20T00:32:37.000Z</published>
    <updated>2017-07-15T01:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>水一篇~</p><a id="more"></a><h2 id="1-善用-Style"><a href="#1-善用-Style" class="headerlink" title="1. 善用 Style"></a>1. 善用 Style</h2><p>写个论文格式什么的要求还是挺多的，标题／正文用什么字体，字号都有规定。要方便设置格式就要善用 Style。</p><p>首先是选择一套与你的需求比较接近的基本主题，可以尽量降低自定义样式的工作量。</p><p>然后你就可以按论文要求自定义 Style 了。打开 Styles Pane，就可以看到预定义的各种样式，可以直接将其应用到文中。针对某一个样式，可以直接进行修改，应用该样式的文本都可以随之更新，是不是很像写 CSS？样式还可以继承已有样式，颇有点 OO 的感觉。</p><h2 id="2-参考文献的-tricks"><a href="#2-参考文献的-tricks" class="headerlink" title="2. 参考文献的 tricks"></a>2. 参考文献的 tricks</h2><p>一篇小论文还用不着 Citation 这么高级的功能，而且我大清自有国情在此，Word 的这个功能也不够本土化。要添加参考文献，只需要用 Cross-reference 就可以了。首先在知网或其他地方导出参考文献格式，复制到文中，然后使用 Word 给它们添加编号，再在原文引用的地方插入 Cross-reference 时直接选择对应的参考文献条目就好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;水一篇~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Marshmallow Runtime Permissions</title>
    <link href="https://wsxyeah.github.io/2017/04/05/Marshmallow-Runtime-Permissions/"/>
    <id>https://wsxyeah.github.io/2017/04/05/Marshmallow-Runtime-Permissions/</id>
    <published>2017-04-05T02:06:33.000Z</published>
    <updated>2017-04-05T03:38:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>从 Android 6.0 （API 23） 开始系统开始将应用权限收紧，将权限分为普通（Normal Permissions）权限与危险权限（Dangerous Permissions）。</p><p>普通权限不会影响到用户的隐私，只要像以往那样在 manifest 中声明即可使用。<br>危险权限不仅要在 manifest 中声明，而且需要获得用户的批准。虽然可以临时将 target API 设置在 23 以下规避，但一来用户仍然可以在系统设置中强制拒绝授予权限造成应用崩溃，二来也并非长久之计。</p><a id="more"></a><h1 id="危险权限及分组"><a href="#危险权限及分组" class="headerlink" title="危险权限及分组"></a>危险权限及分组</h1><p>系统分组处理危险权限的授予，如果应用已经获得某个组内的某项权限，那么也就默认获得了该组内的其他权限。比如我们已经获得了 <code>READ_CONTACTS</code> 权限，那么相当于 <code>CONTACTS</code> 组内的 <code>WRITE_CONTACTS</code> 和 <code>GET_ACCOUNTS</code> 权限也获得了。</p><table><thead><tr><th>Permission Group</th><th>Permissions</th></tr></thead><tbody><tr><td>CALENDAR</td><td><div>READ_CALENDAR</div><div>WRITE_CALENDAR</div></td></tr><tr><td>CAMERA</td><td>CAMERA</td></tr><tr><td>CONTACTS</td><td><div>READ_CONTACTS</div><div>WRITE_CONTACTS</div><div>GET_ACCOUNTS</div></td></tr><tr><td>LOCATION</td><td><div>ACCESS_FINE_LOCATION</div><div>ACCESS_COARSE_LOCATION</div></td></tr><tr><td>MICROPHONE</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE</td><td><div>READ_PHONE_STATE</div><div>CALL_PHONE</div><div>READ_CALL_LOG</div><div>WRITE_CALL_LOG</div><div>ADD_VOICEMAIL</div><div>USE_SIP</div><div>PROCESS_OUTGOING_CALLS</div></td></tr><tr><td>SENSORS</td><td>BODY_SENSORS</td></tr><tr><td>SMS</td><td><div>SEND_SMS</div><div>RECEIVE_SMS</div><div>READ_SMS</div><div>RECEIVE_WAP_PUSH</div><div>RECEIVE_MMS</div></td></tr><tr><td>STORAGE</td><td><div>READ_EXTERNAL_STORAGE</div><div>WRITE_EXTERNAL_STORAGE</div></td></tr></tbody></table><h1 id="基本-API-使用"><a href="#基本-API-使用" class="headerlink" title="基本 API 使用"></a>基本 API 使用</h1><p>与运行时权限相关的 API 主要有以下几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context/ContextCompat</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkSelfPermission</span> <span class="params">(String permission)</span></span></span><br><span class="line"><span class="function"><span class="comment">// Activity/ActivityCompat</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldShowRequestPermissionRationale</span> <span class="params">(String permission)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">requestPermissions</span> <span class="params">(String[] permissions, <span class="keyword">int</span> requestCode)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span> <span class="params">(<span class="keyword">int</span> requestCode, String[] permissions, <span class="keyword">int</span>[] grantResults)</span></span></span><br></pre></td></tr></table></figure><p><code>checkSelfPermission</code> 方法用来检测是否已经获得某项权限，返回结果为<code>PackageManager.PERMISSION_GRANTED</code> 或 <code>PackageManager.PERMISSION_DENIED</code> 。</p><p><code>shouldShowRequestPermissionRationale</code> 表示应用是否应该向用户解释为何需要权限。未请求过该权限时返回 false。</p><p><code>requestPermissions</code> 执行请求权限的实际操作，在调用该方法时，系统弹出对话框让用户选择是否允许获取所请求的权限。<br>如果用户选择了 Never ask again 并拒绝授予，那么之后调用 <code>requestPermissions</code> 请求该权限直接会被拒绝，<code>shouldShowRequestPermissionRationale</code> 都会返回 false。</p><p><code>onRequestPermissionsResult</code> 方法是 Activity 的一个回调方法，类似于 <code>onActivityResult</code>，返回权限请求的结果。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// 未获得该权限</span></span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">        <span class="comment">// 被拒绝过，向用户解释为何需要该权限后再请求</span></span><br><span class="line">        showPermissionExplanation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 之前从未请求过该权限或被永久拒绝，直接发起请求</span></span><br><span class="line">        ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,</span><br><span class="line">                PERMISSION_REQUEST_STORAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">if</span> (requestCode == PERMISSION_REQUEST_STORAGE) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; permissions.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Manifest.permission.WRITE_EXTERNAL_STORAGE.equals(permissions[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (PackageManager.PERMISSION_GRANTED == grantResults[i]) &#123;</span><br><span class="line">                    <span class="comment">// 成功获得权限</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 被拒绝</span></span><br><span class="line">                    <span class="comment">// 如果该权限必须的话，可以检查 shouldShowRequestPermissionRationale</span></span><br><span class="line">                    <span class="comment">// 若返回 true，表示用户永久拒绝，可以引导用户在系统设置中重新授予权限</span></span><br><span class="line">                    <span class="keyword">if</span> (!ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">                        showPermissionGuide();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.android.com/training/permissions/requesting.html" target="_blank">Requesting Permissions at Run Time</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 Android 6.0 （API 23） 开始系统开始将应用权限收紧，将权限分为普通（Normal Permissions）权限与危险权限（Dangerous Permissions）。&lt;/p&gt;
&lt;p&gt;普通权限不会影响到用户的隐私，只要像以往那样在 manifest 中声明即可使用。&lt;br&gt;危险权限不仅要在 manifest 中声明，而且需要获得用户的批准。虽然可以临时将 target API 设置在 23 以下规避，但一来用户仍然可以在系统设置中强制拒绝授予权限造成应用崩溃，二来也并非长久之计。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gradle for Android 笔记</title>
    <link href="https://wsxyeah.github.io/2017/01/18/gradle-for-android/"/>
    <id>https://wsxyeah.github.io/2017/01/18/gradle-for-android/</id>
    <published>2017-01-18T08:03:36.000Z</published>
    <updated>2017-01-18T08:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h1><ul><li>DSL</li><li>based on Groovy</li><li><code>{}</code>：闭包</li></ul><a id="more"></a><h1 id="Gradle-for-Android"><a href="#Gradle-for-Android" class="headerlink" title="Gradle for Android"></a>Gradle for Android</h1><ul><li>用 V 表示集合 Build Variants，T 表示集合 Build Types，F 表示集合 Product Flavors，则 V = T × F。</li><li>e.g.</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/build.gradle</span></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123; <span class="comment">// 当我们在写一个一个的 `&#123;&#125;` 时，其实就是在调用函数，并传一个闭包进去</span></span><br><span class="line">    compileSdkVersion <span class="number">25</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.2"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"me.sxwang.explore"</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">25</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            manifestPlaceholders = [CHANNEL: <span class="string">"official"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 productFlavors 对应</span></span><br><span class="line">    <span class="comment">// void productFlavors(Action&lt;? super NamedDomainObjectContainer&lt;ProductFlavor&gt;&gt; action)</span></span><br><span class="line">    <span class="comment">// 方法，执行该方法内部会调用 action.execute(produtFlavors)。</span></span><br><span class="line">    <span class="comment">// productFlavors 的实际类型为 NamedDomainObjectContainer&lt;ProductFlavor&gt;，</span></span><br><span class="line">    <span class="comment">// NamedDomainObjectContainer 是 Gradle 中定义的一个接口</span></span><br><span class="line">    <span class="comment">// （https://docs.gradle.org/current/dsl/org.gradle.api.NamedDomainObjectContainer.html），</span></span><br><span class="line">    <span class="comment">// 闭包内的代码通过 create(name, configureClosure) ／getByName(name, configureClosure) </span></span><br><span class="line">    <span class="comment">// 方法实现了对 productFlavors 的配置</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        wandoujia &#123;</span><br><span class="line">            manifestPlaceholders = [CHANNEL: <span class="string">"wandoujia"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        xiaomi &#123;</span><br><span class="line">            manifestPlaceholders = [CHANNEL: <span class="string">"xiaomi"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 productFlavors 对应调用 getProductFlavors() 方法，返回类型为 Collection&lt;ProductFlavor&gt;，</span></span><br><span class="line">    <span class="comment">// Collection 是 Groovy JDK 提供的类（http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Collection.html）</span></span><br><span class="line">    <span class="comment">// each() 方法遍历集合中的所有元素，在 Collection 中定义</span></span><br><span class="line">    <span class="comment">// 可见这里使用 each() 仅对前面已经创建的 product flavors 生效</span></span><br><span class="line">    productFlavors.<span class="keyword">each</span> &#123; flavor -&gt;</span><br><span class="line">        <span class="keyword">println</span>(<span class="string">"====&gt; Configuring productFlavor: $&#123;flavor.name&#125;"</span>)</span><br><span class="line">        flavor.manifestPlaceholders = [CHANNEL: flavor.name]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// applicationVariants 为 DomainObjectSet&lt;ApplicationVariant&gt; 类型，</span></span><br><span class="line">    <span class="comment">// 虽然也是 Collection 类型，但是此时其集合元素为空，故使用 each() 无效。</span></span><br><span class="line">    <span class="comment">// 当然 DomainObjectSet 也实现了另一个接口 DomainObjectCollection，接口中定义的</span></span><br><span class="line">    <span class="comment">// all() 方法保证对于后续添加的所有元素都会生效</span></span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        <span class="keyword">println</span>(<span class="string">"====&gt; Configuring variant: $&#123;variant.name&#125;"</span>)</span><br><span class="line">        variant.assemble.dependsOn.<span class="keyword">each</span> &#123; dependency -&gt;</span><br><span class="line">            <span class="keyword">println</span>(dependency)</span><br><span class="line">        &#125;</span><br><span class="line">        variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">            output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(output.outputFile.parent, <span class="string">"x-$&#123;variant.name&#125;.apk"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        variant.assemble.<span class="keyword">doFirst</span> &#123;</span><br><span class="line">            <span class="keyword">println</span>(<span class="string">"====&gt; doFirst: $&#123;variant.name&#125;"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:25.1.0'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:design:25.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a target="_blank" href="http://docs.groovy-lang.org/latest/html/groovy-jdk/">Groovy JDK API Documentation</a></p></li><li><p><a target="_blank" href="https://docs.gradle.org/current/dsl/">Gradle Build Language Reference</a></p></li><li><p><a target="_blank" href="https://docs.gradle.org/current/userguide/userguide.html">Gradle User Guide</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gradle&quot;&gt;&lt;a href=&quot;#Gradle&quot; class=&quot;headerlink&quot; title=&quot;Gradle&quot;&gt;&lt;/a&gt;Gradle&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;DSL&lt;/li&gt;
&lt;li&gt;based on Groovy&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;：闭包&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 的包装类型，自动装箱与拆箱</title>
    <link href="https://wsxyeah.github.io/2016/11/01/java-wrapper-classes/"/>
    <id>https://wsxyeah.github.io/2016/11/01/java-wrapper-classes/</id>
    <published>2016-11-01T13:46:43.000Z</published>
    <updated>2016-11-02T00:22:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 作为一门面向对象的语言，仍然保留了基本的几种值类型（int，short，long，byte，char，boolean，float，double）。当然为了方便开发人员使用也提供了对应的包装类，（Integer，Short，Long，Byte，Char，Boolean，Float，Double），并且在 Java 1.5 中开始提供了自动装箱（boxing）和拆箱（unboxing）特性。</p><p>自动装箱的主要作用是方便在值类型和包装类型之间切换，比如可以直接在源代码里将值类型赋值给包装类型或反之，使用 == 来比较值类型和包装类型的值。这里提到是源代码里这样做是因为自动装箱／拆箱特性主要由编译器帮我们完成。<br><a id="more"></a></p><p>当我们编写以下一段程序时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">Integer b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">assert</span>(a == b);</span><br></pre></td></tr></table></figure><ul><li>其中第一行代码需要将包装类型赋值给值类型，编译器会生成等效于 <code>int a = new Integer(5).intValue();</code> 的代码</li><li>对于第二行，则有 <code>Integer b = Integer.valueOf(6);</code></li><li>而对于值类型与包装类型的比较，则会先将包装类型转为基本类型，即 <code>assert(a.intValue() == b);</code></li></ul><p>关于包装类型的缓存<br>根据 Java 语言规范（JLS8，§5.1.7），包装类型会对部分值做缓存，在像 <code>Integer.valueOf(int)</code> 这样的方法中起作用，所以会出现 <code>Integer a = 5; Integer b = 5; assert(a == b);</code> 的情况。</p><blockquote><p>If the value p being boxed is an integer literal of type int between -128 and 127 inclusive (§3.10.1), or the boolean literal true or false (§3.10.3), or a character literal between ‘\u0000’ and ‘\u007f’ inclusive (§3.10.4), then let a and b be the results of any two boxing conversions of p. It is always the case that a == b.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 作为一门面向对象的语言，仍然保留了基本的几种值类型（int，short，long，byte，char，boolean，float，double）。当然为了方便开发人员使用也提供了对应的包装类，（Integer，Short，Long，Byte，Char，Boolean，Float，Double），并且在 Java 1.5 中开始提供了自动装箱（boxing）和拆箱（unboxing）特性。&lt;/p&gt;
&lt;p&gt;自动装箱的主要作用是方便在值类型和包装类型之间切换，比如可以直接在源代码里将值类型赋值给包装类型或反之，使用 == 来比较值类型和包装类型的值。这里提到是源代码里这样做是因为自动装箱／拆箱特性主要由编译器帮我们完成。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>迁移 NDK 项目到 Gradle</title>
    <link href="https://wsxyeah.github.io/2016/09/21/ndk-with-grale/"/>
    <id>https://wsxyeah.github.io/2016/09/21/ndk-with-grale/</id>
    <published>2016-09-21T03:18:49.000Z</published>
    <updated>2016-11-01T13:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天 Android Studio 2.2 终于出了稳定版，完善了对 NDK 的支持，真可谓是「开发者的大事，大快所有人心的大好事」。</p><h2 id="NDK-集成"><a href="#NDK-集成" class="headerlink" title="NDK 集成"></a>NDK 集成</h2><p>这次 Android Studio 不但支持传统 NDK 项目的集成，同时也支持使用 Cmake 来组织 NDK 代码。Cmake 项目可以在 Gradle 做如下配置<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild&#123;</span><br><span class="line">   cmake&#123;</span><br><span class="line">        path &quot;CMakeLists.txt&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultConfig &#123;</span><br><span class="line">  externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">      targets &quot;target1&quot;, &quot;target2&quot;</span><br><span class="line">      arguments &quot;-DANDROID_TOOLCHAIN=clang&quot;</span><br><span class="line">      cFlags &quot;-DTEST_C_FLAG1&quot;, &quot;-DTEST_C_FLAG2&quot;</span><br><span class="line">      cppFlags &quot;-DTEST_CPP_FLAG2&quot;, &quot;-DTEST_CPP_FLAG2&quot;</span><br><span class="line">      abiFilters &quot;armeabi-v7a&quot;, &quot;armeabi&quot;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于传统的 NDK 项目现在可以在 Gradle 里添加如下配置块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild&#123;</span><br><span class="line">   ndkBuild&#123;</span><br><span class="line">        path &quot;Android.mk&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultConfig &#123;</span><br><span class="line">  externalNativeBuild &#123;</span><br><span class="line">    ndkBuild &#123;</span><br><span class="line">      targets &quot;target1&quot;, &quot;target2&quot;</span><br><span class="line">      arguments &quot;NDK_APPLICATION_MK:=Application.mk&quot;</span><br><span class="line">      cFlags &quot;-DTEST_C_FLAG1&quot;, &quot;-DTEST_C_FLAG2&quot;</span><br><span class="line">      cppFlags &quot;-DTEST_CPP_FLAG2&quot;, &quot;-DTEST_CPP_FLAG2&quot;</span><br><span class="line">      abiFilters &quot;armeabi-v7a&quot;, &quot;armeabi&quot;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>path</code> Android.mk 文件的路径，可以使用相对路径</p><p><code>targets</code> 用来过滤需要打包进 apk 的库，可以针对不同的 product flavor 做配置。只有这里指定的 targets 才会被打包，若未配置则全部打包</p><p><code>abiFilters</code> 这里最好还是再指定一次，Application.mk 里指定的似乎会被忽略。如果 NDK 项目依赖一些平台相关的库或代码并且只有部分平台的依赖，这时会报找不到文件的错误，其实是没有设置 abiFilters 导致它会去找所有平台的文件</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>完成配置并同步 Gradle 之后，在该模块的目录下会生成一个 <code>.externalNativeBuild</code> 目录，目录结构为 <code>.externalNativeBuild/ndkBuild/${ProductFlavor}/${abi}/</code>。<br>里面是生成的构建脚本，包含三个文件。指定了 Android.mk 及 Application.mk 的位置，ndk-build 命令，编译参数及 toolchains 配置。<br>并且从生成的脚本中也可以看出这里已经可以根据 Gradle 中的 Debug/Release 模式生成相应的编译命令了。</p><ul><li>android_gradle_build.json</li><li>ndkBuild_build_command.txt</li><li>ndkBuild_build_output.txt</li></ul><p>如此看来 Gradle 采取的是根据我们的配置生成对应的脚本，在外部执行编译脚本，再将结果进行打包的策略，这样便使原来的项目无缝迁移，同时也为 Cmake 这样的组织方式提供了扩展。</p><p>另外现在可以针对不同渠道做定制了。可以通过在编译器参数中定义宏的方式将参数传进 JNI 中，再在 JNI 代码中做对应处理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://developer.android.com/studio/projects/add-native-code.html" target="_blank" rel="noopener">Add C and C++ Code to Your Project</a></li><li><a href="http://android-developers.blogspot.com/2016/09/android-studio-2-2.html" target="_blank" rel="noopener">Android Studio 2.2</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天 Android Studio 2.2 终于出了稳定版，完善了对 NDK 的支持，真可谓是「开发者的大事，大快所有人心的大好事」。&lt;/p&gt;
&lt;h2 id=&quot;NDK-集成&quot;&gt;&lt;a href=&quot;#NDK-集成&quot; class=&quot;headerlink&quot; title=&quot;NDK 集成&quot;&gt;&lt;/a&gt;NDK 集成&lt;/h2&gt;&lt;p&gt;这次 Android Studio 不但支持传统 NDK 项目的集成，同时也支持使用 Cmake 来组织 NDK 代码。Cmake 项目可以在 Gradle 做如下配置&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JNI 开发中字符编码的一点坑</title>
    <link href="https://wsxyeah.github.io/2016/07/23/jni-charset-encoding/"/>
    <id>https://wsxyeah.github.io/2016/07/23/jni-charset-encoding/</id>
    <published>2016-07-23T09:39:06.000Z</published>
    <updated>2016-07-23T09:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>JNI 开发中 Java 层向下传字符串比较常用的是 JNIEnv 的 GetStringUTFChars 方法将 <code>jstring</code> 转为 <code>const char *</code>，用完后使用 ReleaseStringUTFChars 方法释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> jchar * <span class="title">GetStringChars</span><span class="params">(JNIEnv *env, jstring <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">jboolean *isCopy)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReleaseStringChars</span><span class="params">(JNIEnv *env, jstring <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> jchar *chars)</span></span>;</span><br></pre></td></tr></table></figure><p>然而使用该方法返回的字符串却并非采用标准 UTF-8 编码，而是Modified UTF-8 Strings，即一种修改过的 UTF-8 编码。</p><a id="more"></a><p>标准的 UTF-8 编码以 8-bit 即一个字节为基本单位，一个字符可以由一到六个字节编码表示，只要留出每个字节的高几位作为标志位就可以表示出该字节的类型，这样就可以判断出其后有几个字节与该字节合在一起表示一个字符。比如最高位为 <code>0</code> 表示该字节单独表示一个字符；最高两位为 <code>10</code> 表示该字节是跟在其他字节后面的，仅包含数据；最高三位为 <code>110</code> 则表示它将与后一个字节共同表示同一字符。</p><p>在 Modified UTF-8 Strings 中，<code>U+FFFF</code> 以上编码的字符（比如 Emoji 字符）并没有继续遵循 UTF-8 编码的规则，而是将其拆分为两个部分，分别使用三个字节存放，共六个字节。但这样也就导致了使用 UTF-8 编码解析的话便将会其识别为两个字符。</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>主要有的解决思路有两种，一种是使用 UTF-16 编码，系统提供了对应的 GetStringChars 和 ReleaseStringChars 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> jchar * <span class="title">GetStringChars</span><span class="params">(JNIEnv *env, jstring <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">jboolean *isCopy)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReleaseStringChars</span><span class="params">(JNIEnv *env, jstring <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> jchar *chars)</span></span>;</span><br></pre></td></tr></table></figure><p>另一种是先在 Java 层拿到 UTF-8 编码的字符串 byte[] 数据，再以 jbyteArray 的形式传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = str.getBytes(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jbyteArray _bytes;</span></span><br><span class="line"><span class="keyword">const</span> jsize length = env-&gt;GetArrayLength(_bytes);</span><br><span class="line">jbyte *bytes = env-&gt;GetByteArrayElements(_bytes, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">env-&gt;ReleaseByteArrayElements(_bytes, bytes, JNI_ABORT);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;坑&quot;&gt;&lt;a href=&quot;#坑&quot; class=&quot;headerlink&quot; title=&quot;坑&quot;&gt;&lt;/a&gt;坑&lt;/h2&gt;&lt;p&gt;JNI 开发中 Java 层向下传字符串比较常用的是 JNIEnv 的 GetStringUTFChars 方法将 &lt;code&gt;jstring&lt;/code&gt; 转为 &lt;code&gt;const char *&lt;/code&gt;，用完后使用 ReleaseStringUTFChars 方法释放。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; jchar * &lt;span class=&quot;title&quot;&gt;GetStringChars&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(JNIEnv *env, jstring &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;jboolean *isCopy)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReleaseStringChars&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(JNIEnv *env, jstring &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; jchar *chars)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而使用该方法返回的字符串却并非采用标准 UTF-8 编码，而是Modified UTF-8 Strings，即一种修改过的 UTF-8 编码。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 下搭建 Samba 服务</title>
    <link href="https://wsxyeah.github.io/2016/05/22/ubuntu-samba-service/"/>
    <id>https://wsxyeah.github.io/2016/05/22/ubuntu-samba-service/</id>
    <published>2016-05-22T12:23:56.000Z</published>
    <updated>2016-05-22T13:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要读源码的时候都要到网页上找，网页跳转不仅速度慢也十分麻烦，于是打算把 AOSP 源码同步到本地。<br>由于我的 Mac 剩余磁盘空间只有 100 多 G 了，就用原来联想的机器（用的是 Ubuntu 16.04）同步了 24GB+ 的 AOSP 源码。并打算在上面搭建 Samba 服务，这样就可以直接在 Mac 上阅读源码了，哈哈。</p><a id="more"></a><h2 id="安装-Samba"><a href="#安装-Samba" class="headerlink" title="安装 Samba"></a>安装 Samba</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install samba</span><br></pre></td></tr></table></figure><h2 id="选择共享目录"><a href="#选择共享目录" class="headerlink" title="选择共享目录"></a>选择共享目录</h2><p>直接在 Ubuntu 的文件管理器 GUI 右键菜单里选择 属性 -&gt; 本地文件共享，并勾选<code>共享此目录</code>以及<code>允许其他人来创建和删除这个文件夹里的文件</code>就可以了，系统会为我们自动设置目录的权限及共享配置。</p><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>我们可以单独创建一个用户用于登录 Samba 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd smb</span><br><span class="line">sudo passwd smb</span><br></pre></td></tr></table></figure><p>允许使用该用户登录 Samba 并重启 Samba 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a smb &amp;&amp; sudo service smbd restart</span><br></pre></td></tr></table></figure><p>现在只要在 Finder 左侧边栏选择服务器，点击 <code>Connect as</code> 并使用创建的账户登录就可以直接访问共享目录啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要读源码的时候都要到网页上找，网页跳转不仅速度慢也十分麻烦，于是打算把 AOSP 源码同步到本地。&lt;br&gt;由于我的 Mac 剩余磁盘空间只有 100 多 G 了，就用原来联想的机器（用的是 Ubuntu 16.04）同步了 24GB+ 的 AOSP 源码。并打算在上面搭建 Samba 服务，这样就可以直接在 Mac 上阅读源码了，哈哈。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈 Android 事件分发机制</title>
    <link href="https://wsxyeah.github.io/2016/04/03/touch-event/"/>
    <id>https://wsxyeah.github.io/2016/04/03/touch-event/</id>
    <published>2016-04-03T13:30:04.000Z</published>
    <updated>2016-04-03T23:59:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-形式"><a href="#1-形式" class="headerlink" title="1. 形式"></a>1. 形式</h2><p>Touch 事件被封装成 MotionEvent 对象来传递。<br>由 ACTION_DOWN 开始，经过若干次 ACTION_MOVE 并以 ACTION_UP 结束的一个事件序列称为一个 gesture。</p><h2 id="2-角色"><a href="#2-角色" class="headerlink" title="2. 角色"></a>2. 角色</h2><p>涉及 Touch 事件处理的角色有四种：</p><ul><li>Activity</li><li>Window</li><li>ViewGroup</li><li>View</li></ul><a id="more"></a><h2 id="3-基本流程"><a href="#3-基本流程" class="headerlink" title="3. 基本流程"></a>3. 基本流程</h2><p>事件在 activity 中的分发起始于 <code>dispatchTouchEvent()</code> 方法。从源码可以看出 activity 调用了 Window 的 <code>superDispatchTouchEvent()</code> 方法来处理，若返回值为 true，则结束事件分发，否则调用 <code>onTouchEvent()</code>  方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">onUserInteraction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Window 的实现类为 PhoneWindow，PhoneWindow 实际调用了 DecorView 的 <code>superDispatchTouchEvent()</code>。<br>而 DecorView 是 activity 中的顶级 View，它其实是一个 FrameLayout，它的 <code>superDispatchTouchEvent()</code> 直接调用了 ViewGroup 的 <code>dispatchTouchEvent()</code>。</p><p>由此，事件流入 View 层级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PhoneWindow</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DecorView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-ViewGroup-dispatchTouchEvent-流程"><a href="#4-ViewGroup-dispatchTouchEvent-流程" class="headerlink" title="4. ViewGroup dispatchTouchEvent() 流程"></a>4. ViewGroup <code>dispatchTouchEvent()</code> 流程</h2><p>事件流入 View 层级后会逐级分发，ViewGroup 处在事件分发的中间层，是事件分发机制中最复杂的部分。此处源码非常长，就不贴出来了。</p><p>ACTION_DOWN 事件作为一次 gesture 的开始，可以影响后续事件的传递流程。为了方便理解，这里将它与其他类型的事件分开分析。</p><ul><li>对于 ACITON_DOWN 事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 作为一次 gesture 的开始，重置状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 判断是否需要拦截本次事件</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line"><span class="comment">// 此时 disallowIntercept 已被重置为 false，onInterceptTouchEvent 一定会被调用</span></span><br><span class="line">intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">intercepted = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!intercepted &amp;&amp; mChildrenCount != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 3.a 不进行拦截的情况，向下分发</span></span><br><span class="line"> <span class="comment">// 从前面到后面遍历子 View，这里用循环仅简单表示遍历过程</span></span><br><span class="line"> <span class="keyword">for</span> (View child : mChildren) &#123;</span><br><span class="line"> <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">|| !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="comment">// 该子 View 不可见或触摸位置不在子 View 边界内，跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变换 MotionEvent 并传给子 View 的 dispatchTouchEvent</span></span><br><span class="line"><span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line"><span class="comment">// 若返回 true，表示该子 View 需要处理此次 gesture 的事件，记录此状态</span></span><br><span class="line">handled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 3.b 进行拦截的情况，需要自己处理事件</span></span><br><span class="line">handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于非 ACITON_DOWN 事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 判断是否需要拦截本次事件</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 若之前子 View 调用了 requestDisallowInterceptTouchEvent(true)，则不允许拦截</span></span><br><span class="line">intercepted = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!intercepted &amp;&amp; mChildrenCount != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 2.a 不进行拦截的情况，向下分发</span></span><br><span class="line"> <span class="comment">// 仅遍历之前记录的子 View（即对 ACTION_DOWN 事件返回 true 的子 View）</span></span><br><span class="line"> <span class="comment">// 这里循环仅简单表示遍历过程，实际上源码是使用链表实现的</span></span><br><span class="line"> <span class="keyword">for</span> (View child : children) &#123;</span><br><span class="line"><span class="comment">// 变换 MotionEvent 并传给子 View 的 dispatchTouchEvent</span></span><br><span class="line"><span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">handled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 2.b 进行拦截的情况，需要自己处理事件</span></span><br><span class="line">handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-View-dispatchTouchEvent-流程"><a href="#5-View-dispatchTouchEvent-流程" class="headerlink" title="5. View dispatchTouchEvent() 流程"></a>5. View <code>dispatchTouchEvent()</code> 流程</h2><p>View 位于事件分发的最下层，不再向下分发。View 的事件分发逻辑大致等效于 <code>return mOnTouchListener.onTouch(this, e) || onTouchEvent(e);</code>。</p><p>View 的 OnClickListener 是在 <code>onTouchEvent()</code> 方法里回调的，所以如果我们为 View 设置了 onTouchListener 并在 <code>onTouch()</code> 里返回 true，那么它的 OnClick 等系统预设的事件会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的 View dispatchTouchEvent 代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">ListenerInfo li = mListenerInfo;</span><br><span class="line"><span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line"> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">&amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">result = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">result = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-形式&quot;&gt;&lt;a href=&quot;#1-形式&quot; class=&quot;headerlink&quot; title=&quot;1. 形式&quot;&gt;&lt;/a&gt;1. 形式&lt;/h2&gt;&lt;p&gt;Touch 事件被封装成 MotionEvent 对象来传递。&lt;br&gt;由 ACTION_DOWN 开始，经过若干次 ACTION_MOVE 并以 ACTION_UP 结束的一个事件序列称为一个 gesture。&lt;/p&gt;
&lt;h2 id=&quot;2-角色&quot;&gt;&lt;a href=&quot;#2-角色&quot; class=&quot;headerlink&quot; title=&quot;2. 角色&quot;&gt;&lt;/a&gt;2. 角色&lt;/h2&gt;&lt;p&gt;涉及 Touch 事件处理的角色有四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Activity&lt;/li&gt;
&lt;li&gt;Window&lt;/li&gt;
&lt;li&gt;ViewGroup&lt;/li&gt;
&lt;li&gt;View&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 日期解析与格式化</title>
    <link href="https://wsxyeah.github.io/2016/03/13/date-format/"/>
    <id>https://wsxyeah.github.io/2016/03/13/date-format/</id>
    <published>2016-03-13T00:33:39.000Z</published>
    <updated>2016-04-04T00:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中有 <code>java.text.DateFormat</code> 这个类来专门处理日期格式，它的实例仅能通过三个工厂方法获取，然后就可以调用 <code>format()</code> 和 <code>parse()</code> 方法来格式化和解析了。</p><ul><li><code>DateFormat.getDateInstance([int style[, Locale aLocale]])</code></li><li><code>DateFormat.getDateTimeInstance([int dateStyle, int timeStyle[, Locale aLocale]])</code></li><li><code>DateFormat.getTimeInstance([int style[, Locale aLocale]])</code></li></ul><p>其中的 style 可以是 SHORT， MEDIUM， LONG 或者 FULL。</p><ul><li>SHORT is completely numeric, such as 12.13.52 or 3:30pm</li><li>MEDIUM is longer, such as Jan 12, 1952</li><li>LONG is longer, such as January 12, 1952 or 3:30:32pm</li><li>FULL is pretty completely specified, such as Tuesday, April 12, 1952 AD or 3:30:42pm PST.</li></ul><a id="more"></a><p>我们常用的是其子类 <code>SimpleDateFormat</code>，它可以直接传入一个字符串 pattern 来定义格式，详细文档可以看这里 <a href="http://developer.android.com/intl/zh-cn/reference/java/text/SimpleDateFormat.html" target="_blank" rel="noopener">http://developer.android.com/intl/zh-cn/reference/java/text/SimpleDateFormat.html</a>。</p><p><strong>坑出没注意</strong><br><strong>如果要解析的日期字符串不是纯数字（比如含有用文字表示的的月份或者周几）的话，一定要记得传入 Locale。</strong></p><p>另外一种日期的格式化问题就是弄成那种像 <code>2小时前</code>，<code>1天前</code> 这样的格式。Android 其实自带了一个 <code>DataUtils</code> 类来处理这种格式。</p><p><code>formatDateRange()</code> 可以格式化时间段，比如 <code>3:00pm - 4:00pm</code>，或者 <code>Dec 31, 2007 - Jan 1, 2008</code>。<br><code>formatElapsedTime()</code> 可以传入秒数，格式化成 <code>MM:SS</code> 或 <code>H:MM:SS</code>。<br><code>formatSameDayTime</code> 需要传入 now 参数，对在同一天的时间显示时间，不是同一天则仅显示日期。<br><code>getRelativeDateTimeString()</code> 就是我们常见的 <code>2小时前</code> 格式了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中有 &lt;code&gt;java.text.DateFormat&lt;/code&gt; 这个类来专门处理日期格式，它的实例仅能通过三个工厂方法获取，然后就可以调用 &lt;code&gt;format()&lt;/code&gt; 和 &lt;code&gt;parse()&lt;/code&gt; 方法来格式化和解析了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DateFormat.getDateInstance([int style[, Locale aLocale]])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DateFormat.getDateTimeInstance([int dateStyle, int timeStyle[, Locale aLocale]])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DateFormat.getTimeInstance([int style[, Locale aLocale]])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中的 style 可以是 SHORT， MEDIUM， LONG 或者 FULL。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SHORT is completely numeric, such as 12.13.52 or 3:30pm&lt;/li&gt;
&lt;li&gt;MEDIUM is longer, such as Jan 12, 1952&lt;/li&gt;
&lt;li&gt;LONG is longer, such as January 12, 1952 or 3:30:32pm&lt;/li&gt;
&lt;li&gt;FULL is pretty completely specified, such as Tuesday, April 12, 1952 AD or 3:30:42pm PST.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我对 Android 消息机制的思考</title>
    <link href="https://wsxyeah.github.io/2016/03/03/thinking-about-handler/"/>
    <id>https://wsxyeah.github.io/2016/03/03/thinking-about-handler/</id>
    <published>2016-03-03T13:00:42.000Z</published>
    <updated>2016-11-24T13:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android 中线程间通信消息机制的基本思想其实很简单：为目标线程建立一个消息循环用来“监听”消息，之后我们只要在其他线程中向目标线程发送消息就可以被目标线程接收并处理，这样就完成了两个线程之间的通信。</p><p>下面我们一步一步来分析这个机制的实现（以下源码均基于 SDK 23）。</p><a id="more"></a><h2 id="1-为目标线程建立一个消息循环用来“监听”消息"><a href="#1-为目标线程建立一个消息循环用来“监听”消息" class="headerlink" title="1. 为目标线程建立一个消息循环用来“监听”消息"></a>1. 为目标线程建立一个消息循环用来“监听”消息</h2><p>我们都知道 Java 中一个线程执行的入口点是它的 <code>run()</code> 方法（或者对应 Runable 对象的 <code>run()</code> 方法），我们要为目标线程建立消息循环就需要在此处进行操作，否则线程代码一下子就执行完了，结束掉了。</p><p>这时我们就需要 Looper 来完成这个工作了，从其命名我们就可以看出来它是作为一个“循环器”来使用，它可以方便地为我们的线程建立消息循环。我们在使用 Looper 的时候都是先调用 <code>Looper.prepare()</code> ,然后创建 Handler 作为消息处理器，最后再调用 <code>Looper.loop()</code> 来启动消息循环。</p><p>那么 <code>Looper.prepare()</code> 干了些什么事情呢，我们来看一下其源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">  * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">  * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>sThreadLocal</code> 是 Looper 类的静态 ThreadLocal 类对象。这里先说明一下 ThreadLocal 的作用，ThreadLocal 就是用来从当前线程对象里存取数据的一个工具类。<br>ThreadLocal 使用 <code>Thread.currentThread()</code> 来获得当前代码所在的线程对象，然后把数据存到线程对象中，get 也是从线程对象里取出来。</p><p>我们从源码可以看出来 <strong><code>Looper.prepare()</code> 会向当前线程对象存放一个 Looper 对象</strong>，另外 Looper 对象在创建的时候创建一个 MessageQueue，将其以及当前线程对象作为对象成员。</p><p>再来看 Handler 的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use the &#123;<span class="doctag">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class="line"><span class="comment"> * and set whether the handler should be asynchronous.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class="line"><span class="comment"> * one that is strictly asynchronous.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class="line"><span class="comment"> * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class="line"><span class="comment"> * the synchronization barriers introduced by &#123;<span class="doctag">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> async If true, the handler calls &#123;<span class="doctag">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class="line"><span class="comment"> * each &#123;<span class="doctag">@link</span> Message&#125; that is sent to it or &#123;<span class="doctag">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use the provided &#123;<span class="doctag">@link</span> Looper&#125; instead of the default one and take a callback</span></span><br><span class="line"><span class="comment"> * interface in which to handle messages.  Also set whether the handler</span></span><br><span class="line"><span class="comment"> * should be asynchronous.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class="line"><span class="comment"> * one that is strictly asynchronous.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class="line"><span class="comment"> * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class="line"><span class="comment"> * the synchronization barriers introduced by &#123;<span class="doctag">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> looper The looper, must not be null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> async If true, the handler calls &#123;<span class="doctag">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class="line"><span class="comment"> * each &#123;<span class="doctag">@link</span> Message&#125; that is sent to it or &#123;<span class="doctag">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler 的构造函数可以传入一个 Looper 对象，否则将会调用 <code>Looper.myLooper()</code> 从当前线程对象里取出前面 <code>Looper.prepare()</code> 存的 Looper 对象，之后 Handler 将 Looper 和 MessageQueue 作为对象成员。</p><p>最后我们就可以调用 <code>Looper.loop()</code> 来启动消息循环了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Looper.loop()</code> 会从当前线程对象中把前面存的 Looper 对象以及该对象的 mMessageQueue 取出来（这里取消息是通过调用 MessageQueue 的 <code>next()</code> 方法来取得下一条消息），然后启动消息循环，不停地从 mMessageQueue 里取消息并分派处理，也就是会调用消息对应的 target Handler 的 <code>dispathMessage()</code> 方法，当然这个消息处理过程就与 <code>Looper.loop()</code> 在同一个线程里了。</p><h2 id="2-向目标线程发消息"><a href="#2-向目标线程发消息" class="headerlink" title="2. 向目标线程发消息"></a>2. 向目标线程发消息</h2><p>在 Android 中我们使用 Handler 来完成的。我们从前面就知道 Handler 在创建的时候就会持有一个 MessageQueue 的引用，其实这个就是用来往 MessageQueue 里发消息用的。</p><p>当我们使用 Handler 发消息时，最后都会调用到 Handler 的 <code>enqueueMessage()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 Handler 将 Message 的 target 设置为自己，也就是指定了这条消息将会由自己来处理，然后将 Message 放进 MessageQueue 里面。</p><p>因为 MessageQueue 的 <code>enqueueMessage()</code> 方法的权限是 package level 的，我们不能直接调用，就需要通过 Handler 来把消息发到 MessageQueue 里。</p><p>所以 Handler 的作用主要有两个，一是处理消息，二是作为发消息的一个工具。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>那么根据以上分析，我们可以得出结论：</p><ul><li><p>一个 Looper 对象一定对应于一个线程，一个线程最多有一个 Looper 对象</p></li><li><p>一个 Message 最终由它的 target Handler 来处理</p></li><li><p>一个 Message 会在<strong>持有它所被加入的 MessageQueue 的 Looper 对象</strong>对应的线程中被处理</p></li></ul><p>所以如果我们在子线程中完成了耗时操作想要切换到主线程更新 UI 的时候，思路应该是：</p><p><code>主线程 Looper 的 MessageQueue -&gt; 主线程 Looper -&gt; 构造持有主线程 Looper 的 Handler（new Handler(Looper.getMainLooper())） -&gt; 使用该 Handler 发送消息</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 中线程间通信消息机制的基本思想其实很简单：为目标线程建立一个消息循环用来“监听”消息，之后我们只要在其他线程中向目标线程发送消息就可以被目标线程接收并处理，这样就完成了两个线程之间的通信。&lt;/p&gt;
&lt;p&gt;下面我们一步一步来分析这个机制的实现（以下源码均基于 SDK 23）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Handler" scheme="https://wsxyeah.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>重新认识 Activity LaunchMode</title>
    <link href="https://wsxyeah.github.io/2015/12/19/activity-launch-mode/"/>
    <id>https://wsxyeah.github.io/2015/12/19/activity-launch-mode/</id>
    <published>2015-12-19T08:43:40.000Z</published>
    <updated>2016-04-04T00:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>做 Android 的同学想必对 activity 启动模式都不陌生，activity 有四种启动模式（ <code>standard</code>，<code>singleTop</code>，<code>singleTask</code>，<code>singleInstance</code>），网上和一些书上也有各种讲解，但这些文章大多是针对四种启动模式进行介绍，总是在看过一段时间后就忘掉了。本文希望带你重新理解 activity 启动模式，并理解一些其他的相关概念，而不是仅仅针对四种启动模式。</p><a id="more"></a><h2 id="1-从-Task-说起"><a href="#1-从-Task-说起" class="headerlink" title="1. 从 Task 说起"></a>1. 从 Task 说起</h2><p>Activity 启动模式是与 task 密切相关的，所以我们先从 task 说起。</p><blockquote><p>A task is a collection of activities that users interact with when performing a certain job. The activities are arranged in a stack (the <em>back stack</em>), in the order in which each activity is opened.</p></blockquote><p>上面这句话是官方文档里的，解释了 Android 中 task 的概念，task 就是若干 activity 组成的一个集合，以栈的形式来管理。在 Android 中，每个 activity 都是运行在 task 中的，前台 task 的栈顶 activity 位于前台，可以直接与用户交互。</p><p>那么一个 activity 运行在哪个 task 中是由谁来决定的呢？我们首先来看 taskAffinity，taskAffinity 是影响 Activity 运行在哪个 task 中的第一个因素。</p><p>一个 activity 的 taskAffinity 是我们在 <code>manifests.xml</code> 里定义的，每个 Activity 都可以设置一个 <code>android:taskAffinity</code> 属性，它的值是一个字符串。<code>application</code> 元素也有这个属性，它的默认值是 <code>manifest</code> 元素中指定的包名（<code>package</code> 属性）。对于 Activity 的这个属性，当我们不显式设置的时候它就会从 <code>application</code> 元素继承。</p><p>那么<strong>在 taskAffinity 属性起作用</strong>的情况下，除了 taskAffinity 值为空字符串的 Activity，具有相同 taskAffinity 的 Activity 会运行在同一个 task 中，即使它们处于不同的应用中。taskAffinity 为空字符串表示这个 Activity 不会与其他任何 task 关联。</p><h2 id="2-manifests-xml-中的-launchMode"><a href="#2-manifests-xml-中的-launchMode" class="headerlink" title="2. manifests.xml 中的 launchMode"></a>2. <code>manifests.xml</code> 中的 launchMode</h2><p>我们可以在 <code>manifests.xml</code> 中为 activity 指定 <code>android:launchMode</code> 属性，可以的取值有 <code>standard</code>，<code>singleTop</code>，<code>singleTask</code>，<code>singleInstance</code>，默认值是 <code>standard</code>。</p><p>那么我们不设置 Intent flags（下文会讲到）的情况下启动一个 activity 的时候，系统就会根据 <code>manifests.xml</code> 里设置的 launchMode 来决定 activity 启动模式。下面是四种启动模式的处理说明。</p><ul><li><p><code>standard</code>，<code>singleTop</code>：在当前 task 中启动，<strong>忽略 taskAffinity 属性</strong>。<br>  两种模式的区别是 <code>standard</code> 模式每次启动都会创建新的实例，而 <code>singleTop</code> 模式则是若已经有该 activity 的实例存在于 task 栈顶的情况下不再创建新实例，而是回调该实例的 <code>onNewIntent()</code> 方法。</p></li><li><p><code>singleTask</code>：这时该 activity 要在哪个 task 中运行就由我们前面指定的 taskAffinity 来决定了（该 activity 只能运行在 taskAffinity 与自己的 taskAffinity 相同的 task 中）。并且在这个 task 中该 activity 的实例只允许存在一个，若已经有一个实例在栈顶，就会回调它的 <code>onNewIntent()</code> 方法；若有实例且不在栈顶，系统则会将该 task 中该位于该实例之上的 activity 出栈销毁，使该实例回到前台，并回调其 <code>onNewIntent()</code> 方法。</p></li><li><p><code>singleInstance</code>：与 <code>singleTask</code> 类似，区别在于 <code>singleInstance</code> 的 task 中只能有一个 activity 实例存在，即该 activity 只能单独运行于一个 task 中。</p></li></ul><h2 id="3-Intent-flag"><a href="#3-Intent-flag" class="headerlink" title="3. Intent flag"></a>3. Intent flag</h2><p>影响 activity 启动模式的另一个地方就是 Intent flag 了。我们可以在使用 Intent 启动一个 activity 的时候可以调用 Intent 的 <code>setFlag()</code> 方法来为它设置标志位，且 Intent flag 具有更高的优先级。影响 activity 启动模式的 Intent flag 有下面几个。</p><ul><li><p><code>FLAG_ACTIVITY_NEW_TASK</code>：在新 task 中启动 activity，效果与 <code>singleTask</code> 模式类似，但不会清除目标 activity 之上的 activity。使用这个 flag 可以实现应用间切换的效果。</p></li><li><p><code>FLAG_ACTIVITY_SINGLE_TOP</code>：与 <code>singleTop</code> 模式效果相同。</p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TOP</code>：若目标 activity 在其 task 中已经有实例存在，则将 task 中其上的 activity 出栈销毁，使该实例回到前台，并回调其 <code>onNewIntent()</code> 方法。与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用可以实现 <code>singleTask</code> 模式的效果。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做 Android 的同学想必对 activity 启动模式都不陌生，activity 有四种启动模式（ &lt;code&gt;standard&lt;/code&gt;，&lt;code&gt;singleTop&lt;/code&gt;，&lt;code&gt;singleTask&lt;/code&gt;，&lt;code&gt;singleInstance&lt;/code&gt;），网上和一些书上也有各种讲解，但这些文章大多是针对四种启动模式进行介绍，总是在看过一段时间后就忘掉了。本文希望带你重新理解 activity 启动模式，并理解一些其他的相关概念，而不是仅仅针对四种启动模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LaunchMode" scheme="https://wsxyeah.github.io/tags/LaunchMode/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK 开发环境搭建</title>
    <link href="https://wsxyeah.github.io/2015/12/06/android-ndk-start/"/>
    <id>https://wsxyeah.github.io/2015/12/06/android-ndk-start/</id>
    <published>2015-12-06T03:10:08.000Z</published>
    <updated>2016-04-04T00:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前也曾看过一些介绍 NDK 的文章，但是由于嫌（tuo）麻（yan）烦（zheng）一直没有实践过，这两天读了些文章和文档，打算把 NDK 的项目搭建的一些东西整理一下。</p><p>本文主要介绍 Eclipse 下和 Android Studio 下 NDK 开发环境的搭建。</p><a id="more"></a><h2 id="1-NDK-下载"><a href="#1-NDK-下载" class="headerlink" title="1. NDK 下载"></a>1. NDK 下载</h2><p><a href="http://developer.android.com/ndk/downloads/index.html" target="_blank" rel="noopener">http://developer.android.com/ndk/downloads/index.html</a></p><p>在这里根据平台选择相应的文件下载。</p><ul><li><p>Windows 下面可以直接双击下载的 exe 文件解压。</p></li><li><p>Linux 和 OS X 用户需要进入下载的文件目录，执行下面的命令解压。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x android-ndk-r10c-darwin-x86_64.bin</span><br><span class="line">./android-ndk-r10c-darwin-x86_64.bin</span><br></pre></td></tr></table></figure><h2 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2. 环境变量配置"></a>2. 环境变量配置</h2><p>只要把 NDK 目录加入到系统 PATH 变量就好了，这步是为了方便从命令行执行 NDK 脚本。</p><h2 id="3-Eclipse-下-NDK-项目搭建"><a href="#3-Eclipse-下-NDK-项目搭建" class="headerlink" title="3. Eclipse 下 NDK 项目搭建"></a>3. Eclipse 下 NDK 项目搭建</h2><h3 id="1-首先在-Eclipse-的设置里选择-NDK-目录。"><a href="#1-首先在-Eclipse-的设置里选择-NDK-目录。" class="headerlink" title="1. 首先在 Eclipse 的设置里选择 NDK 目录。"></a>1. 首先在 Eclipse 的设置里选择 NDK 目录。</h3><p><code>Android &gt; NDK &gt; NDK Location</code></p><h3 id="2-新建-Android-项目"><a href="#2-新建-Android-项目" class="headerlink" title="2. 新建 Android 项目"></a>2. 新建 Android 项目</h3><h3 id="3-添加-native-方法"><a href="#3-添加-native-方法" class="headerlink" title="3. 添加 native 方法"></a>3. 添加 native 方法</h3><p>native 方法在方法签名前加 <code>native</code> 关键字，无方法体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">yo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-为项目添加-NDK-支持"><a href="#4-为项目添加-NDK-支持" class="headerlink" title="4. 为项目添加 NDK 支持"></a>4. 为项目添加 NDK 支持</h3><p>在左侧项目视图上点击右键，选择 Android Tools -&gt; Add Native Support…，然后输入 Library Name：libxxx.so，Finish。</p><p>之后 Eclipse 会为我们生成 jni 目录以及 <code>Android.mk</code>，<code>xxx.cpp</code> 两个文件。</p><h3 id="5-生成-jni-头文件"><a href="#5-生成-jni-头文件" class="headerlink" title="5. 生成 jni 头文件"></a>5. 生成 jni 头文件</h3><p>在 Eclipse 中执行 build 命令，然后进入到项目的 <code>bin\classes</code> 目录，执行 <code>javah -cp 完整类名 android.jar</code> 命令，其中完整的类名是指包含包名，<code>android.jar</code> 是 SDK 目录下对应的 compile SDK 版本目录下面的 android.jar 的路径，比如我的 compile SDK 版本是 23，那我的路径就是 <code>SDK目录\platforms\android-23\android.jar</code>。此时会 javah 会为我们在 classes 目录下生成 jni 头文件。</p><h3 id="6-根据-jni-头文件在-xxx-cpp-中编写-native-代码"><a href="#6-根据-jni-头文件在-xxx-cpp-中编写-native-代码" class="headerlink" title="6. 根据 jni 头文件在 xxx.cpp 中编写 native 代码"></a>6. 根据 jni 头文件在 xxx.cpp 中编写 native 代码</h3><p>此处需要注意的是如果使用 C++ 编写，需要定义 <code>extern &quot;C&quot;</code> 宏。</p><p>关于 <code>extern &quot;C&quot;</code> 的详细信息可以参考这篇文章 <a href="http://www.jianshu.com/p/5d2eeeb93590" target="_blank" rel="noopener">extern “c”用法解析</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Class:     me_sxwang_jnipractice_MainActivity</span></span><br><span class="line"><span class="comment">* Method:    yo</span></span><br><span class="line"><span class="comment">* Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_me_sxwang_jnipractice_MainActivity_yo</span><br><span class="line">(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line"><span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"I come from JNI."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="7-编译-native-代码"><a href="#7-编译-native-代码" class="headerlink" title="7. 编译 native 代码"></a>7. 编译 native 代码</h3><p>进入项目根目录，使用 <code>ndk-build</code> 命令执行编译，编译完成后会在项目的 <code>libs</code> 目录下生成相应的 so 文件。</p><h3 id="8-加载-jni-库，运行调试"><a href="#8-加载-jni-库，运行调试" class="headerlink" title="8. 加载 jni 库，运行调试"></a>8. 加载 jni 库，运行调试</h3><p>在类中添加初始化代码段加载 jni 库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.loadLibrary(<span class="string">"xxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Android-Studio-下-NDK-项目搭建（基于-Android-Studio-1-5）"><a href="#4-Android-Studio-下-NDK-项目搭建（基于-Android-Studio-1-5）" class="headerlink" title="4. Android Studio 下 NDK 项目搭建（基于 Android Studio 1.5）"></a>4. Android Studio 下 NDK 项目搭建（基于 Android Studio 1.5）</h2><h3 id="1-新建-Android-项目"><a href="#1-新建-Android-项目" class="headerlink" title="1. 新建 Android 项目"></a>1. 新建 Android 项目</h3><h3 id="2-在项目的-Project-Structure-中选择-NDK-所在目录"><a href="#2-在项目的-Project-Structure-中选择-NDK-所在目录" class="headerlink" title="2. 在项目的 Project Structure 中选择 NDK 所在目录"></a>2. 在项目的 Project Structure 中选择 NDK 所在目录</h3><h3 id="3-为-build-gradle-Module-app-添加-NDK-模块"><a href="#3-为-build-gradle-Module-app-添加-NDK-模块" class="headerlink" title="3. 为 build.gradle (Module: app) 添加 NDK 模块"></a>3. 为 <code>build.gradle (Module: app)</code> 添加 NDK 模块</h3><p><del>在 android &gt; defaultConfig 下新增如下片段，执行 build，会提示需要在 gradle.properties 添加 <code>android.useDeprecatedNdk=true</code>，根据提示添加完后重新 build 一下。</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ndk &#123;</span><br><span class="line">moduleName &quot;xxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="">https://bintray.com/android/android-tools/com.android.tools.build.gradle-experimental/view</a> 查看 gradle-experimental 插件的最新版，并在 Project 的 buildscript&gt;dependencies classpath 中替换原有的插件。<br>启用 gralde-experimental 需要修改 module 的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.model.application&apos;</span><br><span class="line">model &#123;</span><br><span class="line">android &#123;</span><br><span class="line">compileSdkVersion = 23</span><br><span class="line">buildToolsVersion = &quot;23.0.1&quot;</span><br><span class="line"></span><br><span class="line">defaultConfig.with &#123;</span><br><span class="line">applicationId = &quot;com.google.sample.helloandroidjni&quot;</span><br><span class="line">minSdkVersion.apiLevel = 22</span><br><span class="line">targetSdkVersion.apiLevel = 23</span><br><span class="line">versionCode = 1</span><br><span class="line">versionName = &quot;1.0&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">android.buildTypes &#123;</span><br><span class="line">release &#123;</span><br><span class="line">minifyEnabled = false</span><br><span class="line">proguardFiles.add(file(&apos;proguard-android.txt&apos;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建-native-方法"><a href="#4-创建-native-方法" class="headerlink" title="4. 创建 native 方法"></a>4. 创建 native 方法</h3><p>同 Eclipse</p><h3 id="5-生成-jni-文件"><a href="#5-生成-jni-文件" class="headerlink" title="5. 生成 jni 文件"></a>5. 生成 jni 文件</h3><p>在 native 方法名上，按 <code>Option ＋ Enter</code> 键根据提示选择第一项 Create function …，Android Studio 会自动为我们生成相应的 c 文件，及方法签名等信息，方便我们编写 native 代码。</p><h3 id="6-编写-native-代码，加载-jni-库，运行调试"><a href="#6-编写-native-代码，加载-jni-库，运行调试" class="headerlink" title="6. 编写 native 代码，加载 jni 库，运行调试"></a>6. 编写 native 代码，加载 jni 库，运行调试</h3><p>同 Eclipse，Android Studio 会自动帮我们编译 native 代码，无需手动编译</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前也曾看过一些介绍 NDK 的文章，但是由于嫌（tuo）麻（yan）烦（zheng）一直没有实践过，这两天读了些文章和文档，打算把 NDK 的项目搭建的一些东西整理一下。&lt;/p&gt;
&lt;p&gt;本文主要介绍 Eclipse 下和 Android Studio 下 NDK 开发环境的搭建。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NDK" scheme="https://wsxyeah.github.io/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android 异步加载数据方式整理</title>
    <link href="https://wsxyeah.github.io/2015/11/22/android-async/"/>
    <id>https://wsxyeah.github.io/2015/11/22/android-async/</id>
    <published>2015-11-22T02:43:12.000Z</published>
    <updated>2016-07-23T10:01:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 中，由于主线程负责维护 UI，不能被阻塞，那么在通过磁盘或者网络进行异步加载数据的时候就需要使用多线程了。以下是我整理的几种使用多线程执行异步操作的方式，如有纰漏欢迎指正。</p><a id="more"></a><h2 id="1-Handler"><a href="#1-Handler" class="headerlink" title="1. Handler"></a>1. Handler</h2><p>   Android 中多线程通信基本的方式是使用 Handler 机制，基本使用方式如下。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//init handler on the original thread</span><br><span class="line">class OriginalThread extends Thread &#123;</span><br><span class="line"> public Handler mHandler;</span><br><span class="line"> public void run() &#123;</span><br><span class="line">   Looper.prepare();</span><br><span class="line">   mHandler = new Handler() &#123;</span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line">     // process incoming messages here</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   Looper.loop();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//send message to the original thread</span><br><span class="line">mHandler.post(Runnable);</span><br><span class="line">mHandler.postAtTime(Runnable, long);</span><br><span class="line">mHandler.postDelayed(Runnable, long);</span><br><span class="line">mHandler.sendEmptyMessage(int);</span><br><span class="line">mHandler.sendMessage(Message);</span><br><span class="line">mHandler.sendMessageAtTime(Message, long);</span><br><span class="line">mHandler.sendMessageDelayed(Message, long);</span><br></pre></td></tr></table></figure><p>   系统还内置了AsyncQueryHandler 辅助子类，方便使用 ContentResolver 进行异步查询操作。</p><p>   关于 Handler，需要注意的是，当 Handler 被声明为 Activity 的非静态内部类时， Handler 会持有外部 Activity 实例的引用，Handler 生命周期比 Activity 长时会导致 Activity 实例不能被正常释放，从而引起内存泄漏。一种解决方式是将 Handler 声明为 Activity 的静态内部类或者单独的类，在 Handler 内部使用 WeakReference/SoftReference 保存对 Activity的引用，既能访问 Activity 的 View 更新 UI，又可以避免内存泄漏。</p><h2 id="2-AsyncTask"><a href="#2-AsyncTask" class="headerlink" title="2. AsyncTask"></a>2. AsyncTask</h2><p>   AsyncTask 方式是官方提供的用来简化手动写 Handler 的一种异步机制，其内部仍使用 Handler 实现。</p><p>   需要继承AsyncTask&lt;Params, Progress, Result&gt;类，重写doInBackground，onPostExecute等回调方法，使用的时候调用 execute 方法（只能在 UI 线程调用）传入参数就可以方便的执行 IO 或网络等耗时操作并在操作完成时更新 UI。</p><p>   使用 AsyncTask 同样需要注意内存泄漏问题。</p><h2 id="3-Activity-runOnUiThread-Runnable-action"><a href="#3-Activity-runOnUiThread-Runnable-action" class="headerlink" title="3. Activity.runOnUiThread(Runnable action)"></a>3. Activity.runOnUiThread(Runnable action)</h2><p>   算是 Handler 方式的一种语法糖吧，使用了 Activity 自身维护的 一个 mHandler 实例，便于在 UI 线程执行操作，比如异步获取数据后更新 UI。</p><h2 id="4-Loader"><a href="#4-Loader" class="headerlink" title="4. Loader"></a>4. Loader</h2><p>   Loader 是在 Android 3.0 引入的用于在 Activity 和 Fragment 中简化异步加载数据的方式。</p><p>   系统提供了 AsyncTaskLoader<d> 和 CursorLoader 两个子类。</d></p><h2 id="5-View-post-Runnable-action-View-postDelayed-Runnable-action-long-delayMillis"><a href="#5-View-post-Runnable-action-View-postDelayed-Runnable-action-long-delayMillis" class="headerlink" title="5. View.post(Runnable action)/View.postDelayed(Runnable action, long delayMillis)"></a>5. View.post(Runnable action)/View.postDelayed(Runnable action, long delayMillis)</h2><h2 id="6-RxJava"><a href="#6-RxJava" class="headerlink" title="6. RxJava"></a>6. RxJava</h2><p>   使用 RxJava 可以方便地进行多线程调度，通过调用 Observable.subscribeOn 和 Observable.observeOn，并使用 Schedulers.io() 和 Schedulers.mainThread() 等工厂方法传入参数即可自由切换线程。</p><h2 id="7-EventBus"><a href="#7-EventBus" class="headerlink" title="7. EventBus"></a>7. EventBus</h2><p>   使用 EventBus 可以在任意线程发布数据，并通过订阅方法的命名约定规定在何种线程执行订阅的回调方法。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Called in the same thread (default)</span><br><span class="line">public void onEvent(MessageEvent event) &#123;</span><br><span class="line">log(event.message);</span><br><span class="line">&#125;</span><br><span class="line">// Called in Android UI&apos;s main thread</span><br><span class="line">public void onEventMainThread(MessageEvent event) &#123;</span><br><span class="line">textField.setText(event.message);</span><br><span class="line">&#125;</span><br><span class="line">// Called in the background thread</span><br><span class="line">public void onEventBackgroundThread(MessageEvent event)&#123;</span><br><span class="line">saveToDisk(event.message);</span><br><span class="line">&#125;</span><br><span class="line">// Called in a separate thread</span><br><span class="line">public void onEventAsync(MessageEvent event)&#123;</span><br><span class="line">backend.send(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Android 中，由于主线程负责维护 UI，不能被阻塞，那么在通过磁盘或者网络进行异步加载数据的时候就需要使用多线程了。以下是我整理的几种使用多线程执行异步操作的方式，如有纰漏欢迎指正。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Async" scheme="https://wsxyeah.github.io/tags/Async/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wsxyeah.github.io/2015/11/06/hello-world/"/>
    <id>https://wsxyeah.github.io/2015/11/06/hello-world/</id>
    <published>2015-11-06T02:47:20.000Z</published>
    <updated>2016-04-04T00:23:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io
      
    
    </summary>
    
    
  </entry>
  
</feed>
