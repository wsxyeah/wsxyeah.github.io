<!DOCTYPE html><html lang="default"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android 异步加载数据方式整理 · 王少星的个人博客</title><meta name="description" content="Android 异步加载数据方式整理 - 王少星"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://wsxyeah.github.io/atom.xml" title="王少星的个人博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/friends/" target="_self" class="nav-list-link">FRIENDS</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android 异步加载数据方式整理</h1><div class="post-info">Nov 22, 2015</div><div class="post-content"><p>在 Android 中，由于主线程负责维护 UI，不能被阻塞，那么在通过磁盘或者网络进行异步加载数据的时候就需要使用多线程了。以下是我整理的几种使用多线程执行异步操作的方式，如有纰漏欢迎指正。</p>
<a id="more"></a>
<h2 id="1-Handler"><a href="#1-Handler" class="headerlink" title="1. Handler"></a>1. Handler</h2><p>   Android 中多线程通信基本的方式是使用 Handler 机制，基本使用方式如下。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//init handler on the original thread</span><br><span class="line">class OriginalThread extends Thread &#123;</span><br><span class="line"> public Handler mHandler;</span><br><span class="line"> public void run() &#123;</span><br><span class="line">   Looper.prepare();</span><br><span class="line">   mHandler = new Handler() &#123;</span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line">     	// process incoming messages here</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   Looper.loop();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//send message to the original thread</span><br><span class="line">mHandler.post(Runnable);</span><br><span class="line">mHandler.postAtTime(Runnable, long);</span><br><span class="line">mHandler.postDelayed(Runnable, long);</span><br><span class="line">mHandler.sendEmptyMessage(int);</span><br><span class="line">mHandler.sendMessage(Message);</span><br><span class="line">mHandler.sendMessageAtTime(Message, long);</span><br><span class="line">mHandler.sendMessageDelayed(Message, long);</span><br></pre></td></tr></table></figure>
<p>   系统还内置了AsyncQueryHandler 辅助子类，方便使用 ContentResolver 进行异步查询操作。</p>
<p>   关于 Handler，需要注意的是，当 Handler 被声明为 Activity 的非静态内部类时， Handler 会持有外部 Activity 实例的引用，Handler 生命周期比 Activity 长时会导致 Activity 实例不能被正常释放，从而引起内存泄漏。一种解决方式是将 Handler 声明为 Activity 的静态内部类或者单独的类，在 Handler 内部使用 WeakReference/SoftReference 保存对 Activity的引用，既能访问 Activity 的 View 更新 UI，又可以避免内存泄漏。</p>
<h2 id="2-AsyncTask"><a href="#2-AsyncTask" class="headerlink" title="2. AsyncTask"></a>2. AsyncTask</h2><p>   AsyncTask 方式是官方提供的用来简化手动写 Handler 的一种异步机制，其内部仍使用 Handler 实现。</p>
<p>   需要继承AsyncTask&lt;Params, Progress, Result&gt;类，重写doInBackground，onPostExecute等回调方法，使用的时候调用 execute 方法（只能在 UI 线程调用）传入参数就可以方便的执行 IO 或网络等耗时操作并在操作完成时更新 UI。</p>
<p>   使用 AsyncTask 同样需要注意内存泄漏问题。</p>
<h2 id="3-Activity-runOnUiThread-Runnable-action"><a href="#3-Activity-runOnUiThread-Runnable-action" class="headerlink" title="3. Activity.runOnUiThread(Runnable action)"></a>3. Activity.runOnUiThread(Runnable action)</h2><p>   算是 Handler 方式的一种语法糖吧，使用了 Activity 自身维护的 一个 mHandler 实例，便于在 UI 线程执行操作，比如异步获取数据后更新 UI。</p>
<h2 id="4-Loader"><a href="#4-Loader" class="headerlink" title="4. Loader"></a>4. Loader</h2><p>   Loader 是在 Android 3.0 引入的用于在 Activity 和 Fragment 中简化异步加载数据的方式。</p>
<p>   系统提供了 AsyncTaskLoader<d> 和 CursorLoader 两个子类。</d></p>
<h2 id="5-View-post-Runnable-action-View-postDelayed-Runnable-action-long-delayMillis"><a href="#5-View-post-Runnable-action-View-postDelayed-Runnable-action-long-delayMillis" class="headerlink" title="5. View.post(Runnable action)/View.postDelayed(Runnable action, long delayMillis)"></a>5. View.post(Runnable action)/View.postDelayed(Runnable action, long delayMillis)</h2><h2 id="6-RxJava"><a href="#6-RxJava" class="headerlink" title="6. RxJava"></a>6. RxJava</h2><p>   使用 RxJava 可以方便地进行多线程调度，通过调用 Observable.subscribeOn 和 Observable.observeOn，并使用 Schedulers.io() 和 Schedulers.mainThread() 等工厂方法传入参数即可自由切换线程。</p>
<h2 id="7-EventBus"><a href="#7-EventBus" class="headerlink" title="7. EventBus"></a>7. EventBus</h2><p>   使用 EventBus 可以在任意线程发布数据，并通过订阅方法的命名约定规定在何种线程执行订阅的回调方法。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Called in the same thread (default)</span><br><span class="line">public void onEvent(MessageEvent event) &#123;</span><br><span class="line">	log(event.message);</span><br><span class="line">&#125;</span><br><span class="line">// Called in Android UI&apos;s main thread</span><br><span class="line">public void onEventMainThread(MessageEvent event) &#123;</span><br><span class="line">	textField.setText(event.message);</span><br><span class="line">&#125;</span><br><span class="line">// Called in the background thread</span><br><span class="line">public void onEventBackgroundThread(MessageEvent event)&#123;</span><br><span class="line">	saveToDisk(event.message);</span><br><span class="line">&#125;</span><br><span class="line">// Called in a separate thread</span><br><span class="line">public void onEventAsync(MessageEvent event)&#123;</span><br><span class="line">	backend.send(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2015/12/06/android-ndk-start/" class="prev">PREV</a><a href="/2015/11/06/hello-world/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://wsxyeah.github.io">王少星</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>